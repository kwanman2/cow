#include "defs.h"

// NOTES:
// jon_interp_mnewt.c is same as mnewt.c except debug statements, such as those inside debugfail>? are removed since lots of functions called in debug (at end of mnewt.c).  Also removed DEBUGPOINT stuff and mpildsum0 commands
// nrutil.c, coord.c, lubksb.c, ludcmp.c same

// decs.h, defs.h, and global.h are mostly different with some things borrowed from HARM

// newt,brodyn have choice added for analytic jacobian
// rest are same




static void interp_init(void);
static void setup_zones(void);
static void interp_readcommandlineargs(int argc, char *argv[]);
static void readdata_preprocessdata(void);

static void setup_interpolation_memory(void);

static void input_header(void);
static void output_header(void);
static void output2file_postinterpolation(void);


static void old_usage(int argc, int basicargcnum);
static void usage(int argc, int basicargcnum);

static void interpret_commandlineresults(void);
void interpret_commandlineresults_subpart1(void);

static void old_parse_commandline(int argc, char *argv[]);
static void parse_commandline(int argc, char *argv[]);

static void defaultoptions(void);

static void post_coordsetup(void);

static void print_out_example_usage(void);



int main(int argc, char *argv[])
{
  
  // Initialize interpolation
  interp_init();

  // Read and process command line commands
  interp_readcommandlineargs(argc, argv);

  input_header();

  // read in coordinate parameters (after inputting header that may determine defcoord, etc.)
  set_coord_parms(defcoord); // set to default
  read_coord_parms(defcoord); // read if file has updated values (as generated by user's init_grid() in grmhd for example)

  // do things once header read-in and coordinates setup
  post_coordsetup();

  // setup grid data information (in case header info different from commandline, use header info)
  setup_zones();

  // setup new grid parameters(before waited till after refinement)
  setup_newgrid();

  // now can output header for new grid
  output_header();

  // read data and preprocess data before interpolation
  readdata_preprocessdata();

  if(immediateoutput>0){
    // then done!
    // flush outputs
    fflush(stderr);
    fflush(stdout);
    if(outfile!=NULL) fflush(outfile);
    return(0);
  }


  // setup grid data information (pre-refinement)
  setup_zones();


  if(doinginterpolation){


    setup_interpolation_memory();

    // only refine or setup new grid if doing interpolation

    // refine data
    refine_data();

    // setup boundaries and zones for old grid (post refinement)
    setup_zones();
  }



  ///////////////////
  //
  // interpolation
  //
  ///////////////////
  if(doinginterpolation==0){
    // avoid interpolation if not necessary
    fprintf(stderr,"No spatial interpolation necessary since grid same and oN0=nN0=%d oN1=nN1=%d  oN2=nN2=%d  oN3=nN3=%d\n",oN0,oN1,oN2,oN3);
    copy_old2new();
  }
  else{
    compute_spatial_interpolation();
  }


  // output file after interpolation
  output2file_postinterpolation();


  // flush outputs
  fflush(stderr);
  fflush(stdout);
  if(outfile!=NULL) fflush(outfile);
  return(0);
}




// allocate global arrays for interpolation memory
static void setup_interpolation_memory(void)
{

  if(ALLOCATENEWIMAGEDATA==0) return; // not allocating newimage or newdata, just outputting directly during interpolation.  Saves huge memory on large interpolations

  fprintf(stderr,"Allocating newdata or newimage\n"); fflush(stderr);

  if(DATATYPE==0){
    newimage  = c5matrix(0,numoutputcols-1,-numbc[0]+0,nN0-1+numbc[0],-numbc[1]+0,nN1-1+numbc[1],-numbc[2]+0,nN2-1+numbc[2],-numbc[3]+0,nN3-1+numbc[3]) ;
    if(newimage==NULL){
      fprintf(stderr,"Couldn't allocate newimage\n"); fflush(stderr);
      myexit(1);
    }
  }
  else{
    newdata  = f5matrix(0,numoutputcols-1,-numbc[0]+0,nN0-1+numbc[0],-numbc[1]+0,nN1-1+numbc[1],-numbc[2]+0,nN2-1+numbc[2],-numbc[3]+0,nN3-1+numbc[3]) ;   // newdata[col][h][i][j][k]
    if(newdata==NULL){
      fprintf(stderr,"Couldn't allocate newdata\n"); fflush(stderr);
      myexit(1);
    }
  }

}




static void interp_init(void)
{

  //  NX1=N1;
  //NX2=N2;
  //NX3=N3;
  //NX1BND=N1BND;
  //NX2BND=N2BND;
  //NX3BND=N3BND;

  NUMEPSILONPOW23=pow(NUMEPSILON,2.0/3.0);

  bytesize=sizeof(unsigned char);
  intsize=sizeof(int);
  longintsize=sizeof(long int);
  longlongintsize=sizeof(long long int);
  floatsize=sizeof(float);
  doublesize=sizeof(double);
  longdoublesize=sizeof(long double);


  // some dummy assignments to make menwt.c and coord.c work, even if don't use these quantities
  ncpux1=0;
  numprocs=1;
  mycpupos[1]=0;
  mycpupos[2]=0;
  mycpupos[3]=0;
  horizoni=horizoncpupos1=0;
  didstorepositiondata=0; // so don't really need dxdxpstore, idxdxpstore, Xstore, Vstore.  So don't need to (but one can) reorder N?M as in global.storage.h
  myid=0;
  debugfail=0;
  nstroke=0;
  failed=0;
  nstep=0;
  //  N1BND=N2BND=N3BND=0;

  // fire up random number generator
  ranc(1,0);


}







static void interp_readcommandlineargs(int argc, char *argv[])
{
  int i;




  // set default options
  defaultoptions();


  /////////////////////////////
  //
  // parse command-line arguments
  //
  /////////////////////////////
  parse_commandline(argc, argv); // will be switching to switches


  if(VERBOSITY>=2){
    // report arguments
    for(i=0;i<argc;i++){
      fprintf(stderr,"argv[%d]=%s\n",i,argv[i]);
    }
  }


  /////////////////////////////
  //
  // process results from command-line arguments into normal/expected parameters setup
  //
  /////////////////////////////
  interpret_commandlineresults();


}




// setup oldgrid zones
static void setup_zones(void)
{
  int j;
 
  ////////////////////////////
  //
  // setup boundaries and zones for old grid (pre refinement)
  //
  ///////////////////////////
    
  if(immediateoutput==0){
    totalsize[0]=oN0;
    totalsize[1]=oN1;
    totalsize[2]=oN2;// in case changed, setup for set_points
    totalsize[3]=oN3;
  }
  else{
    // then get totalsize from header and oN? from command line since can be different if only converting part of original dataset
  }

  fprintf(stderr,"ts0=%d ts1=%d ts2=%d ts3=%d :: oN0=%d oN1=%d oN2=%d oN3=%d\n",totalsize[0],totalsize[1],totalsize[2],totalsize[3],oN0,oN1,oN2,oN3);
  fprintf(stderr,"sx0=%g sx1=%g sx2=%g sx3=%g\n",startx[0],startx[1],startx[2],startx[3]);



  //////////////
  //
  // setup startx[] and dx[] and Diffx[] and endx[] and dV and dVF
  //
  //////////////
  set_points();


  /////////////
  //
  // check if user did something funny
  //
  ////////////
  DLOOPA(j){
    if(fabs(Diffx[j])<SMALL){
      fprintf(stderr,"User: You have startx and endx the same.  Did you interp after already reading an interp file and forget to load the original dump?\n");
      exit(1);
    }
  }


  fprintf(stderr,"after set_points(): sx0=%g sx1=%g sx2=%g sx3=%g\n",startx[0],startx[1],startx[2],startx[3]);

  DLOOPA(j) dX[j]=dx[j];// just convert from coord.c code result

  startpos[0]=startpos[1]=startpos[2]=startpos[3]=0;
  Xmax[0] = startx[0]+dX[0]*(FTYPE)oN0;
  Xmax[1] = startx[1]+dX[1]*(FTYPE)oN1;
  Xmax[2] = startx[2]+dX[2]*(FTYPE)oN2;
  Xmax[3] = startx[3]+dX[3]*(FTYPE)oN3;
  
  // below 2 not really used (yet at least) -- needed for setRin() but that function isn't used
  a=spin;
  Rhor=rhor_calc(0);

  fprintf(stderr,"defcoord=%d Rin=%g R0=%g dofull2pi=%d\n",defcoord,Rin,R0,dofull2pi);

  fprintf(stderr,"startx,Xmax,dX: %g %g %g :: %g %g %g :: %g %g %g :: %g %g %g\n",startx[0],Xmax[0],dX[0],startx[1],Xmax[1],dX[1],startx[2],Xmax[2],dX[2],startx[3],Xmax[3],dX[3]) ; fflush(stderr);

}




void gdump_tostartofdata(FILE** gdumpinlocal)
{

  rewind(*gdumpinlocal);
  // skip first line assuming it's a header line if READHEADERGDUMP=1
  if(READHEADERGDUMP) while(fgetc(*gdumpinlocal)!='\n'); // go past end of line (i.e. assume if binaryoutput=0/1 still text header if requesting to read the header)
  

}

void infile_tostartofdata(FILE** infilelocal)
{

  rewind(*infilelocal);
  // skip first line assuming it's a header line if READHEADER=1
  if(READHEADER) while(fgetc(*infilelocal)!='\n'); // go past end of line (i.e. assume if binaryoutput=0/1 still text header if requesting to read the header)
  

}


// read and process input data
static void readdata_preprocessdata(void)
{
  int coli,h,i,j,k;
  int colini;
  unsigned char tempuc;
  int doubleworkfake;


  if(getgdump){
    gdumpin=fopen(gdumpfilename,"rt");
    if(gdumpin==NULL){
      fprintf(stderr,"No such gdump file %s\n",gdumpfilename);
      exit(1);
    }
    else{
      gdump_tostartofdata(&gdumpin);
    }
  }




  ///////////////////////////////////
  //
  // read data
  //


  ///////////////////////////////////
  //
  // DATATYPE==0
  //
  // only images with 1 column of byte size
  ///////////////////////////////////
  if(DATATYPE==0){
    imagedata=0; // says treat as image and fit output between 0-255
    if(DOUBLEWORK) DATATYPE=1;

    /* make arrays for images */
    if(!DOUBLEWORK){
      oldimage0 = c5matrix(0,0,-numbc[0]+0,oN0-1+numbc[0],-numbc[1]+0,oN1-1+numbc[1],-numbc[2]+0,oN2-1+numbc[2],-numbc[3]+0,oN3-1+numbc[3]) ;
      if(oldimage0==NULL){
        fprintf(stderr,"Couldn't allocate oldimage0\n"); fflush(stderr);
        myexit(1);
      }
    }
    else{
      olddata0 = f5matrix(0,0,-numbc[0]+0,oN0-1+numbc[0],-numbc[1]+0,oN1-1+numbc[1],-numbc[2]+0,oN2-1+numbc[2],-numbc[3]+0,oN3-1+numbc[3]) ;   // olddata0[col][h][i][j][k]
      if(olddata0==NULL){
        fprintf(stderr,"Couldn't allocate olddata0\n"); fflush(stderr);
        myexit(1);
      }
    }
    /* read in old image */
    if(jonheader){
      // skip 4 lines
      for(i=1;i<=4;i++) while(fgetc(infile)!='\n');
    }
    fprintf(stderr,"reading image\n"); fflush(stderr);

    
    // read order and write order same, so good image output
    coli=0; // only 1 column
    totalmin[coli]=BIG;
    totalmax[coli]=-BIG;
    for(h=0;h<oN0;h++){ // for files (reading-writing), time is slowest index
      for(k=0;k<oN3;k++){
        for(j=0;j<oN2;j++){
          for(i=0;i<oN1;i++){
            if(DOUBLEWORK){
              fread(&tempuc, sizeof(unsigned char), 1, infile) ;
              olddata0[coli][h][i][j][k]=(FTYPE)tempuc;
              if(olddata0[coli][h][i][j][k]>totalmax[coli]) totalmax[coli]=olddata0[coli][h][i][j][k];
              if(olddata0[coli][h][i][j][k]<totalmin[coli]) totalmin[coli]=olddata0[coli][h][i][j][k];
            }
            else{
              fread(&oldimage0[coli][h][i][j][k], sizeof(unsigned char), 1, infile) ;
              if(oldimage0[coli][h][i][j][k]>totalmax[coli]) totalmax[coli]=oldimage0[coli][h][i][j][k];
              if(oldimage0[coli][h][i][j][k]<totalmin[coli]) totalmin[coli]=oldimage0[coli][h][i][j][k];
            }
          }
        }
      }
    }

    // filter or not
    if(filter){
      // filter not setup for periodic bc
      fprintf(stderr,"filter\n");
      gaussian_filter(filter,sigma,oN0,oN1,oN2,oN3,oldimage0,olddata0);      
    }

    // apply boundary conditions
    apply_boundaryconditions_olddata(numoutputcols, oN0, numbc[0], DOUBLEWORK, oldimage0, olddata0);

  }



  ///////////////////////////////////
  //
  // DATATYPE>=1
  //
  ///////////////////////////////////
  else{


    imagedata=1; // says treat as data


    if(immediateoutput==1){
      // only ever inputting and outputting at once and don't interpolate and don't need to store more than 1 grid point
      compute_preprocess(outputvartype,gdumpin, 0,0,0,0,NULL, NULL);


    }
    else{
      // case where need to process more than 1 grid point at a time (i.e. integrals or averages or interpolations or whatever)


      ////////////////
      fprintf(stderr,"Before allocate olddata0: %d %d %d %d %d %d %d %d %d %d\n",0,numoutputcols-1,-numbc[0]+0,oN0-1+numbc[0],-numbc[1]+0,oN1-1+numbc[1],-numbc[2]+0,oN2-1+numbc[2],-numbc[3]+0,oN3-1+numbc[3]); fflush(stderr);
      // ALLOCATE MEMORY for storing HARM-based processed data (olddata0)
      olddata0 = f5matrix(0,numoutputcols-1,-numbc[0]+0,oN0-1+numbc[0],-numbc[1]+0,oN1-1+numbc[1],-numbc[2]+0,oN2-1+numbc[2],-numbc[3]+0,oN3-1+numbc[3]) ;   // olddata0[coli][h][i][j][k]
      if(olddata0==NULL){
        fprintf(stderr,"Couldn't allocate olddata0\n"); fflush(stderr);
        myexit(1);
      }
      fprintf(stderr,"After allocate olddata0\n"); fflush(stderr);



      
      // compute additional quantities that can be transformed, processesed, and/or eventually interpolated
      // so far creates olddatacurrent globally if doing anything
      // ensure olddata0 allocated if computing everything in compute_additionals()
      compute_additionals();





      //////////////////
      // PREPARE FOR LOOP
      //
      // initialize totalmin and totalmax
      for(coli=0;coli<numoutputcols;coli++){ // over all independent columsn of data
        totalmin[coli]=BIG;
        totalmax[coli]=-BIG;
      }
      // read it (Note the loop order!) (see global.jon_interp.h)  time is slowest index for reading and writing files
      int kprior,firsttimecompute=1;


      // setup temp new column space to avoid passing entire array "olddata0" to functions because "coli" is at the front of array storage function, when only need per space-time point.
      FTYPE *olddata0temp=(FTYPE*)malloc((unsigned)(numoutputcols)*sizeof(FTYPE));
      if(olddata0temp==NULL){
        fprintf(stderr,"Couldn't allocate olddata0temp\n");
        exit(1);
      }


      FTYPE *olddata0temporig=NULL;
      if(outputvartype==0){
        // old column space
        olddata0temporig=(FTYPE*)malloc((unsigned)(numcolumns)*sizeof(FTYPE));
        if(olddata0temporig==NULL){
          fprintf(stderr,"Couldn't allocate olddata0temporig\n");
          exit(1);
        }
      }


      ////////////
      // LOOP over HARM data and get use multiple values to get (e.g.) Cartesian orthonormal result
      //
      // no iteration over coli -- multiple input columns handled by outputvartype>0
      int hprior=-1000;
      LOOPOLDDATA{
 
        // only 1 thing in (e.g. for scalar image or data)
        if(outputvartype==0){
          for(colini=0;colini<numcolumns;colini++) readelement(binaryinput,inFTYPE,infile,&olddata0temporig[colini]);

          // if multiple input columns, choose 0th column, unless selecting part of field line file
          if(DATATYPE==1000){
            coli=0; colini=0;  olddata0[coli][h][i][j][k]=olddata0temporig[colini]; // rho_0
          }
          else if(DATATYPE==1001){
            coli=0; colini=1;  olddata0[coli][h][i][j][k]=olddata0temporig[colini]; // u_g
          }
          else{
            coli=0; colini=0;  olddata0[coli][h][i][j][k]=olddata0temporig[colini]; // first or only column
          }


        }
        else{
          // for reading anything larger than 1 item per grid point or for non-interpolation type diagnostics
          int dotstoappear;
          dotstoappear=oN0*oN3;


          if(firsttimecompute==1){
            fprintf(stderr,"compute_preprocess(%d dots to appear):",dotstoappear); fflush(stderr);
          }
          if(k!=kprior){
            fprintf(stderr,"."); fflush(stderr);
            kprior=k;
          }

          // reset gdump if changed time -- assumes gdump same for each time so don't have to create multi-time gdump
          if(h!=hprior && oN0!=1){
            gdump_tostartofdata(&gdumpin);
            hprior=h;
          }


          // get new columns by processing data
          compute_preprocess(outputvartype, gdumpin, h,i,j,k,olddatacurrent, olddata0temp);


          // copy from temp space
          for(coli=0;coli<numoutputcols;coli++)  olddata0[coli][h][i][j][k]=olddata0temp[coli];

        }

        // determine min/max of data
        for(coli=0;coli<numoutputcols;coli++){ // over all independent columsn of data
          if(olddata0[coli][h][i][j][k]>totalmax[coli]) totalmax[coli]=olddata0[coli][h][i][j][k];
          if(olddata0[coli][h][i][j][k]<totalmin[coli]) totalmin[coli]=olddata0[coli][h][i][j][k];
        }
 
        firsttimecompute=0;
      }// end LOOPOLDDATA


      // free temp column space
      free(olddata0temp);
      if(outputvartype==0){
        free(olddata0temporig);
      }


      if(filter){
        // filter not setup for periodic bc
        fprintf(stderr,"filter\n");
        gaussian_filter(filter,sigma,oN0,oN1,oN2,oN3,oldimage0,olddata0);
      }



      // apply boundary conditions (spatial and temporal) on HARM-grid data
      doubleworkfake=1; // force use of olddata0
      apply_boundaryconditions_olddata(numoutputcols,oN0,numbc[0],doubleworkfake,oldimage0,olddata0);



    }// end else if immediateoutput!=1

  }// end else if DATATYPE>=1








  if(doinginterpolation){ // only need to set defaultvalue if doing interpolation
    ///////////////
    //
    // set default value of interpolation when nothing to interpolate if not extrapolating
    //
    ///////////////

    if(defaultvaluetype==0){
      if(DATATYPE==14){ // then select per output variable
        for(coli=0;coli<numoutputcols;coli++) defaultvalue[coli]=0.0; // default
        // now set
        defaultvalue[0]=totalmin[0]; // rho0
        defaultvalue[1]=totalmin[1]; // ug
        defaultvalue[2]=0.0; // vx
        defaultvalue[3]=0.0; // vy
        defaultvalue[4]=0.0; // vz
        defaultvalue[5]=0.0; // Bx
        defaultvalue[6]=0.0; // By
        defaultvalue[7]=0.0; // Bz
        defaultvalue[8]=0.0; // FEMrad
        defaultvalue[9]=0.0; // Bphi
        if(docurrent==1){
          defaultvalue[9]=0.0; // Jt (can be + or -, so choose 0 as default)
          defaultvalue[10]=0.0; // Jx
          defaultvalue[11]=0.0; // Jy
          defaultvalue[12]=0.0; // Jz
        }
      }
      else if(DATATYPE==15){ // then select per output variable
        for(coli=0;coli<numoutputcols;coli++) defaultvalue[coli]=0.0; // default
        // now set
        defaultvalue[0]=totalmin[0]; // rho0
        defaultvalue[1]=totalmin[1]; // ug
        defaultvalue[2]=1.0; // uu0
        defaultvalue[3]=0.0; // bsq
      }
      else if(DATATYPE==16){ // then select per output variable
        for(coli=0;coli<numoutputcols;coli++) defaultvalue[coli]=0.0; // default
        // now set
        defaultvalue[0]=totalmin[0]; // rho0
        defaultvalue[1]=totalmin[1]; // ug
        defaultvalue[2]=1.0; // uu0
        defaultvalue[3]=0.0; // bsq
        defaultvalue[4]=log10(totalmin[0]); // lrho
        defaultvalue[5]=-log10(totalmin[0]); // -lrho
        defaultvalue[6]=log10(totalmin[0]); // lbsq
        defaultvalue[7]=0.0; // R
      }
      else if(DATATYPE==17){ // then select per output variable
        for(coli=0;coli<numoutputcols;coli++) defaultvalue[coli]=0.0; // default
        // now set
        defaultvalue[0]=totalmin[0]; // rho0
        defaultvalue[1]=totalmin[1]; // ug
        defaultvalue[2]=1.0; // uu0
        defaultvalue[3]=0.0; // bsq
        defaultvalue[4]=log10(totalmin[0]); // lrho
        defaultvalue[5]=-log10(totalmin[0]); // -lrho
        defaultvalue[6]=log10(totalmin[0]); // lbsq
        defaultvalue[7]=0.0; // R
        defaultvalue[8]=0.0; // vx
        defaultvalue[9]=0.0; // vy
        defaultvalue[10]=0.0; // vz
        defaultvalue[11]=0.0; // bx
        defaultvalue[12]=0.0; // by
        defaultvalue[13]=0.0; // bz
      }
      else if(DATATYPE==18){ // then select per output variable
        for(coli=0;coli<numoutputcols;coli++) defaultvalue[coli]=0.0; // default
        // now set
        defaultvalue[0]=totalmin[0]; // rho0
        defaultvalue[1]=totalmin[1]; // ug
        defaultvalue[2]=1.0; // uu0
        defaultvalue[3]=0.0; // bsq
        defaultvalue[4]=log10(totalmin[0]); // lrho
        defaultvalue[5]=-log10(totalmin[0]); // -lrho
        defaultvalue[6]=log10(totalmin[0]); // lbsq
        defaultvalue[7]=0.0; // R
        defaultvalue[8]=0.0; // vx
        defaultvalue[9]=0.0; // vy
        defaultvalue[10]=0.0; // vz
        defaultvalue[11]=0.0; // bx
        defaultvalue[12]=0.0; // by
        defaultvalue[13]=0.0; // bz
        defaultvalue[14]=0.0; // posr
        defaultvalue[15]=0.0; // posh
        defaultvalue[16]=0.0; // posph
        defaultvalue[17]=0.0; // posx
        defaultvalue[18]=0.0; // posy
        defaultvalue[19]=0.0; // posz
      }
      else if(DATATYPE==19){ // then select per output variable
        for(coli=0;coli<numoutputcols;coli++) defaultvalue[coli]=0.0; // default
        // now set
        defaultvalue[0]=totalmin[0]; // rho0
        defaultvalue[1]=totalmin[1]; // ug
        defaultvalue[2]=1.0; // uu0
        defaultvalue[3]=0.0; // bsq
        defaultvalue[4]=log10(totalmin[0]); // lrho
        defaultvalue[5]=-log10(totalmin[0]); // -lrho
        defaultvalue[6]=log10(totalmin[0]); // lbsq
        defaultvalue[7]=0.0; // R
        defaultvalue[8]=0.0; // vx
        defaultvalue[9]=0.0; // vy
        defaultvalue[10]=0.0; // vz
        defaultvalue[11]=0.0; // bx
        defaultvalue[12]=0.0; // by
        defaultvalue[13]=0.0; // bz
        defaultvalue[14]=0.0; // posr
        defaultvalue[15]=0.0; // posh
        defaultvalue[16]=0.0; // posph
        defaultvalue[17]=0.0; // PRAD0
        defaultvalue[18]=0.0; // PRAD1
        defaultvalue[19]=0.0; // PRAD2
        defaultvalue[20]=0.0; // PRAD3
        defaultvalue[21]=0.0; // FEMrad
        defaultvalue[22]=0.0; // FEMrad2
        defaultvalue[23]=0.0; // FEMrad3
        defaultvalue[24]=0.0; // FEMrad4
        defaultvalue[25]=0.0; // FEMrad5
        defaultvalue[26]=0.0; // Fmomx
        defaultvalue[27]=0.0; // Bphi
        defaultvalue[28]=0.0; // Bphi boosted
        defaultvalue[29]=0.0; // OmegaF
        defaultvalue[30]=0.0; // OmegaF boosted
      }
      else{
        for(coli=0;coli<numoutputcols;coli++){ // over all independent columsn of data
          if(outputvartype==0 || (outputvartype==1||outputvartype==2) && vectorcomponent==0) defaultvalue[coli]=totalmin[coli];
          else defaultvalue[coli]=0.0; // vector-like things otherwise around 0
        }
      }
    }
    else if(defaultvaluetype==1){
      for(coli=0;coli<numoutputcols;coli++) defaultvalue[coli]=totalmin[coli];
    }
    else if(defaultvaluetype==2){
      for(coli=0;coli<numoutputcols;coli++) defaultvalue[coli]=totalmax[coli];
    }
    else if(defaultvaluetype==3){
      for(coli=0;coli<numoutputcols;coli++) defaultvalue[coli]=0.0;
    }
    else if(defaultvaluetype==4){
      for(coli=0;coli<numoutputcols;coli++){
        defaultvalue[coli]=1E35; // for V5D missing data
        fprintf(stderr,"Using V5D missing data for defaultvalue[coli=%d]=%g\n",coli,defaultvalue[coli]);
      }
    }


    if(VERBOSITY>=1){
      for(coli=0;coli<numoutputcols;coli++) fprintf(stderr,"defaultvalue[coli=%d]=%21.15g\n",coli,defaultvalue[coli]);
    }

  }
}



















/////////////
//
// set boundary conditions (as if scalars) to original HARM-grid data
//
///////////// 
void apply_boundaryconditions_olddata(int numcols, int oN0local, int numbc0local, int doubleworklocal, unsigned char *****oldimagelocal, FTYPE *****olddatalocal)
{
  int coli,h,i,j,k;
  int numbclocal[NDIM];
  int jj;

  DLOOPA(jj) numbclocal[jj]=numbc[jj];
  // now override if user wants (e.g. if doing DATATYPE==14 with 3-time data and don't want additional temporal boundary conditions -- would only waste space)
  numbclocal[TT]=numbc0local;


  /////////////
  //
  // set boundary conditions (as if scalars)
  //
  ///////////// 
  for(coli=0;coli<numcols;coli++){ // over all independent columsn of data
      
    if(BOUNDARYEXTRAP==1){
      // lower and upper h
      for(i=0;i<oN1;i++){
        for(j=0;j<oN2;j++){
          for(k=0;k<oN3;k++){
            if(doubleworklocal){
              for(h=-numbclocal[0];h<0;h++) olddatalocal[coli][h][i][j][k]=olddatalocal[coli][0][i][j][k];
              for(h=oN0local;h<oN0local+numbclocal[0];h++) olddatalocal[coli][h][i][j][k]=olddatalocal[coli][oN0local-1][i][j][k];
            }
            else{
              for(h=-numbclocal[0];h<0;h++) oldimage0[coli][h][i][j][k]=oldimage0[coli][0][i][j][k];
              for(h=oN0local;h<oN0local+numbclocal[0];h++) oldimage0[coli][h][i][j][k]=oldimage0[coli][oN0local-1][i][j][k];
            }
          }
        }
      }
      // lower and upper i
      for(h=0;h<oN0local;h++){
        for(j=0;j<oN2;j++){
          for(k=0;k<oN3;k++){
            if(doubleworklocal){
              for(i=-numbclocal[1];i<0;i++) olddatalocal[coli][h][i][j][k]=olddatalocal[coli][h][0][j][k];
              for(i=oN1;i<oN1+numbclocal[1];i++) olddatalocal[coli][h][i][j][k]=olddatalocal[coli][h][oN1-1][j][k];
            }
            else{
              for(i=-numbclocal[1];i<0;i++) oldimage0[coli][h][i][j][k]=oldimage0[coli][h][0][j][k];
              for(i=oN1;i<oN1+numbclocal[1];i++) oldimage0[coli][h][i][j][k]=oldimage0[coli][h][oN1-1][j][k];
            }
          }
        }
      }
      // lower and upper j
      for(h=0;h<oN0local;h++){
        for(i=0;i<oN1;i++){
          for(k=0;k<oN3;k++){
            if(doubleworklocal){
              for(j=-numbclocal[2];j<0;j++) olddatalocal[coli][h][i][j][k]=olddatalocal[coli][h][i][0][k];
              for(j=oN2;j<oN2+numbclocal[2];j++) olddatalocal[coli][h][i][j][k]=olddatalocal[coli][h][i][oN2-1][k];
            }
            else{
              for(j=-numbclocal[2];j<0;j++) oldimage0[coli][h][i][j][k]=oldimage0[coli][h][i][0][k];
              for(j=oN2;j<oN2+numbclocal[2];j++) oldimage0[coli][h][i][j][k]=oldimage0[coli][h][i][oN2-1][k];
            }
          }
        }
      }
      // lower and upper k
      for(h=0;h<oN0local;h++){
        for(j=0;j<oN2;j++){
          for(i=0;i<oN1;i++){
            if(doubleworklocal){
              for(k=-numbclocal[3];k<0;k++) olddatalocal[coli][h][i][j][k]=olddatalocal[coli][h][i][j][0];
              for(k=oN3;k<oN3+numbclocal[3];k++) olddatalocal[coli][h][i][j][k]=olddatalocal[coli][h][i][j][oN3-1];
            }
            else{
              for(k=-numbclocal[3];k<0;k++) oldimage0[coli][h][i][j][k]=oldimage0[coli][h][i][j][0];
              for(k=oN3;k<oN3+numbclocal[3];k++) oldimage0[coli][h][i][j][k]=oldimage0[coli][h][i][j][oN3-1];
            }
          }
        }
      }
    }// end if BOUNDARYEXTRAP=1
      
      
    if(PERIODICINPHI && oN3>1 && oldgridtype==GRIDTYPESPC){
      // then fill boundary cells for good interpolation rather than ad hoc extrapolation that leaves feature at \phi=0=2\pi boundary
      for(h=0;h<oN0local;h++){
        for(j=0;j<oN2;j++){
          for(i=0;i<oN1;i++){
            if(doubleworklocal){
              for(k=-numbclocal[3];k<0;k++) olddatalocal[coli][h][i][j][k]=olddatalocal[coli][h][i][j][k+oN3];
              for(k=oN3;k<oN3+numbclocal[3];k++) olddatalocal[coli][h][i][j][k]=olddatalocal[coli][h][i][j][k-oN3];
            }
            else{
              for(k=-numbclocal[3];k<0;k++) oldimage0[coli][h][i][j][k]=oldimage0[coli][h][i][j][k+oN3];
              for(k=oN3;k<oN3+numbclocal[3];k++) oldimage0[coli][h][i][j][k]=oldimage0[coli][h][i][j][k-oN3];
            }
          }
        }
      }
    }// end if periodic

  }// end over coli



  if(smoothpole) apply_boundaryconditions_olddata_cleanpole(numcols, oN0local, numbc0local, doubleworklocal, oldimagelocal, olddatalocal);


}


/////////////
//
// smooth pole (as if scalars) to original HARM-grid data
//
// assume boundary conditions already applied
//
///////////// 
void apply_boundaryconditions_olddata_cleanpole(int numcols, int oN0local, int numbc0local, int doubleworklocal, unsigned char *****oldimagelocal, FTYPE *****olddatalocal)
{
  int coli,h,i,j,k;
  int numbclocal[NDIM];
  int jj;

  DLOOPA(jj) numbclocal[jj]=numbc[jj];
  // now override if user wants (e.g. if doing DATATYPE==14 with 3-time data and don't want additional temporal boundary conditions -- would only waste space)
  numbclocal[TT]=numbc0local;


#define SMOOTHSIZE MIN(oN2,3) // number of j-cells +-SMOOTHSIZE to use.  Always use all k-cells.


  FTYPE ftemp[2];
  int count[2];


  /////////////
  //
  // smooth spherical polar axis (as if scalars)
  //
  ///////////// 
  for(coli=0;coli<numcols;coli++){ // over all independent columns of data

    // skip non-simulation data things so don't smooth (e.g.) spatial position information
    if(DATATYPE==16 && coli==7) continue;
    if(DATATYPE==17 && coli==7) continue;
    if(DATATYPE==18 && (coli==7 || coli==14 || coli==15 || coli==16 || coli==17 || coli==18 || coli==19 ) ) continue;
    if(DATATYPE==19 && (coli==7 || coli==14 || coli==15 || coli==16) ) continue;
    


    if(oldgridtype==GRIDTYPESPC){ // only method right now applies if original PRIMECOORD grid is spherical polar grid.
      // over all h and i
      for(h=0;h<oN0local;h++){
        for(i=0;i<oN1;i++){

          if(doubleworklocal){
            // form average
            // no need to include boundary cells and do extra work since just copies of active cells
            ftemp[0]=ftemp[1]=0.0;
            count[0]=count[1]=0;
            for(k=0;k<oN3;k++) for(j=0;j<SMOOTHSIZE;j++){ ftemp[0]+=olddatalocal[coli][h][i][j][k]; count[0]++; }
            for(k=0;k<oN3;k++) for(j=oN2-SMOOTHSIZE;j<oN2;j++){ ftemp[1]+=olddatalocal[coli][h][i][j][k]; count[1]++; }
            // assign average to all members, including boundary cells!
            if(count[0]!=0) for(k=-numbclocal[3];k<oN3+numbclocal[3];k++) for(j=-MIN(numbclocal[2],SMOOTHSIZE);j<SMOOTHSIZE;j++) olddatalocal[coli][h][i][j][k]=ftemp[0]/((FTYPE)count[0]);
            if(count[1]!=0) for(k=-numbclocal[3];k<oN3+numbclocal[3];k++) for(j=oN2-SMOOTHSIZE;j<oN2+MIN(numbclocal[2],SMOOTHSIZE);j++) olddatalocal[coli][h][i][j][k]=ftemp[1]/((FTYPE)count[1]);
          } // end if doubleworklocal==1
          else{
            // no need to include boundary cells and do extra work since just copies of active cells
            // form average
            ftemp[0]=ftemp[1]=0.0;
            count[0]=count[1]=0;
            for(k=0;k<oN3;k++) for(j=0;j<SMOOTHSIZE;j++){ ftemp[0]+=oldimage0[coli][h][i][j][k]; count[0]++; }
            for(k=0;k<oN3;k++) for(j=oN2-SMOOTHSIZE;j<oN2;j++){ ftemp[1]+=oldimage0[coli][h][i][j][k]; count[1]++; }
            // assign average to all members, including boundary cells!
            if(count[0]!=0) for(k=-numbclocal[3];k<oN3+numbclocal[3];k++) for(j=-MIN(numbclocal[2],SMOOTHSIZE);j<SMOOTHSIZE;j++) oldimage0[coli][h][i][j][k]=ftemp[0]/((FTYPE)count[0]);
            if(count[1]!=0) for(k=-numbclocal[3];k<oN3+numbclocal[3];k++) for(j=oN2-SMOOTHSIZE;j<oN2+MIN(numbclocal[2],SMOOTHSIZE);j++) oldimage0[coli][h][i][j][k]=ftemp[1]/((FTYPE)count[1]);
          } // end if doubleworklocal==1
   

        }// over i
      } // over h
    }
  }// end over coli



}







// read single element from file in text or binary format and any element C type
void readelement(int binaryinputlocal, char* inFTYPElocal, FILE *input, FTYPE *datain)
{
  
  if     (binaryinputlocal==0 && strcmp(inFTYPElocal,"b")==0   ){ int dumi;             fscanf(input,"%d",&dumi) ;    *datain=(FTYPE)dumi;       }
  else if(binaryinputlocal==0 && strcmp(inFTYPElocal,"i")==0   ){ int dumi;             fscanf(input,"%d",&dumi) ;    *datain=(FTYPE)dumi;       }
  else if(binaryinputlocal==0 && strcmp(inFTYPElocal,"li")==0  ){ long int dumli;       fscanf(input,"%ld",&dumli);   *datain=(FTYPE)dumli;      }
  else if(binaryinputlocal==0 && strcmp(inFTYPElocal,"lli")==0 ){ long long int dumlli; fscanf(input,"%lld",&dumlli); *datain=(FTYPE)dumlli;     }
  else if(binaryinputlocal==0 && strcmp(inFTYPElocal,"f")==0   ){ float dumf;           fscanf(input,"%f",&dumf) ;    *datain=(FTYPE)dumf;       }
  else if(binaryinputlocal==0 && strcmp(inFTYPElocal,"d")==0   ){ double dumd;          fscanf(input,"%lf",&dumd);    *datain=(FTYPE)dumd;       }
  else if(binaryinputlocal==0 && strcmp(inFTYPElocal,"ld")==0  ){ long double dumld;    fscanf(input,"%Lf",&dumld);   *datain=(FTYPE)dumld;      }

  if     (binaryinputlocal==1 && strcmp(inFTYPElocal,"b")==0   ){ int dumi;             fread(&dumi,bytesize,1,input);          *datain=(FTYPE)dumi;       }
  else if(binaryinputlocal==1 && strcmp(inFTYPElocal,"i")==0   ){ int dumi;             fread(&dumi,intsize,1,input);           *datain=(FTYPE)dumi;       }
  else if(binaryinputlocal==1 && strcmp(inFTYPElocal,"li")==0  ){ long int dumli;       fread(&dumli,longintsize,1,input);      *datain=(FTYPE)dumli;      }
  else if(binaryinputlocal==1 && strcmp(inFTYPElocal,"lli")==0 ){ long long int dumlli; fread(&dumlli,longlongintsize,1,input); *datain=(FTYPE)dumlli;     }
  else if(binaryinputlocal==1 && strcmp(inFTYPElocal,"f")==0   ){ float dumf;           fread(&dumf,floatsize,1,input);         *datain=(FTYPE)dumf;       }
  else if(binaryinputlocal==1 && strcmp(inFTYPElocal,"d")==0   ){ double dumd;          fread(&dumd,doublesize,1,input);        *datain=(FTYPE)dumd;       }
  else if(binaryinputlocal==1 && strcmp(inFTYPElocal,"ld")==0  ){ long double dumld;    fread(&dumld,longdoublesize,1,input);   *datain=(FTYPE)dumld;      }

}

// write single element to file in text or binary format and any element C type
void writeelement(int binaryoutputlocal, char* outFTYPElocal, FILE *output, FTYPE dataout)
{
  
  if     (binaryoutputlocal==0 && strcmp(outFTYPElocal,"b")==0   ){ int dumi=(int)dataout;                       fprintf(output,"%d",dumi) ;      }
  else if(binaryoutputlocal==0 && strcmp(outFTYPElocal,"i")==0   ){ int dumi=(int)dataout;                       fprintf(output,"%d",dumi) ;      }
  else if(binaryoutputlocal==0 && strcmp(outFTYPElocal,"li")==0  ){ long int dumli=(long int)dataout;            fprintf(output,"%ld",dumli);     }
  else if(binaryoutputlocal==0 && strcmp(outFTYPElocal,"lli")==0 ){ long long int dumlli=(long long int)dataout; fprintf(output,"%lld",dumlli);   }
  else if(binaryoutputlocal==0 && strcmp(outFTYPElocal,"f")==0   ){ float dumf=(float)dataout;                   fprintf(output,"%15.7g",dumf) ;  }
  else if(binaryoutputlocal==0 && strcmp(outFTYPElocal,"d")==0   ){ double dumd=(double)dataout;                 fprintf(output,"%22.16g",dumd);  }
  else if(binaryoutputlocal==0 && strcmp(outFTYPElocal,"ld")==0  ){ long double dumld=(long double)dataout;      fprintf(output,"%26.21Lg",dumld); }

  if     (binaryoutputlocal==1 && strcmp(outFTYPElocal,"b")==0   ){ int dumi=(int)dataout;                       fwrite(&dumi,bytesize,1,output);          }
  else if(binaryoutputlocal==1 && strcmp(outFTYPElocal,"i")==0   ){ int dumi=(int)dataout;                       fwrite(&dumi,intsize,1,output);           }
  else if(binaryoutputlocal==1 && strcmp(outFTYPElocal,"li")==0  ){ long int dumli=(long int)dataout;            fwrite(&dumli,longintsize,1,output);      }
  else if(binaryoutputlocal==1 && strcmp(outFTYPElocal,"lli")==0 ){ long long int dumlli=(long long int)dataout; fwrite(&dumlli,longlongintsize,1,output); }
  else if(binaryoutputlocal==1 && strcmp(outFTYPElocal,"f")==0   ){ float dumf=(float)dataout;                   fwrite(&dumf,floatsize,1,output);         }
  else if(binaryoutputlocal==1 && strcmp(outFTYPElocal,"d")==0   ){ double dumd=(double)dataout;                 fwrite(&dumd,doublesize,1,output);        }
  else if(binaryoutputlocal==1 && strcmp(outFTYPElocal,"ld")==0  ){ long double dumld=(long double)dataout;      fwrite(&dumld,longdoublesize,1,output);   }

}


// read single element from file in text or binary format and any element C type
long sizeelement(char* inFTYPElocal)
{
  
  if     ( strcmp(inFTYPElocal,"b")==0   ){ int dumi;             return(sizeof(dumi));       }
  else if( strcmp(inFTYPElocal,"i")==0   ){ int dumi;             return(sizeof(dumi));       }
  else if( strcmp(inFTYPElocal,"li")==0  ){ long int dumli;       return(sizeof(dumli));      }
  else if( strcmp(inFTYPElocal,"lli")==0 ){ long long int dumlli; return(sizeof(dumlli));     }
  else if( strcmp(inFTYPElocal,"f")==0   ){ float dumf;           return(sizeof(dumf));       }
  else if( strcmp(inFTYPElocal,"d")==0   ){ double dumd;          return(sizeof(dumd));       }
  else if( strcmp(inFTYPElocal,"ld")==0  ){ long double dumld;    return(sizeof(dumld));      }
  else{
    fprintf(stderr,"No such inFTYPE=%s\n",inFTYPElocal);
    exit(1);
  }
}




// input header from dump file
// does not consider time component dimension
static void input_header(void)
{
  FTYPE ftemp;


  /* read in old data (only designed for 1 column right now)*/
  if(READHEADER){
    // assumes header really has ALL this info (could tell user how many entries on header with wc and compare against desired.
    // GODMARK
    // If using gammie.m's interpsingle, must keep interpsingle macro's header output up-to-date
    if(OLDERHEADER==2) fscanf(infile, SCANHEADER2,SCANHEADERARGS2);
    else if(OLDERHEADER==1) fscanf(infile, SCANHEADER1,SCANHEADERARGS1);
    else if(OLDERHEADER==0) fscanf(infile, SCANHEADER0,SCANHEADERARGS0);


    // set other things not set by header, but not really used right now
    startx[0]=0;  // will be set by set_points() to be this way, but put here to user knows this has to be true
    //endx[0]=???


    realnstep=(long)readnstep;
    nstep=realnstep;
    if(oldparse){ // only a problem at this point if oldparse==1 and READHEADER==1 since old parse line needs to have correct oN?
      if((totalsize[1]!=oN1)||(totalsize[2]!=oN2)||(totalsize[3]!=oN3)){
        fprintf(stderr,"expected %d x %d x %d and got %d x %d x %d resolution -- ok if totalsize sets grid and oN? sets data size in file itself\n",oN1,oN2,oN3,totalsize[1],totalsize[2],totalsize[3]);
      }
    }
    while(fgetc(infile)!='\n'); // go past end of line (so can add stuff to end of header, but won't be funneled to new interpolated file)
  }

  // print header from file
  fprintf(stderr,"PRINTSCANHEADER\n");
  if(OLDERHEADER==2) fprintf(stderr,PRINTSCANHEADER2,PRINTHEADERARGS2);
  else if(OLDERHEADER==1) fprintf(stderr,PRINTSCANHEADER1,PRINTHEADERARGS1);
  else if(OLDERHEADER==0) fprintf(stderr,PRINTSCANHEADER0,PRINTHEADERARGS0);


}



// output dump header
// does not consider time component dimension
static void output_header(void)
{
  FTYPE ftemp;

 
  //////////////////////////
  //
  // output header
  //
  //////////////////////////
  fprintf(stderr,"header:\n");
  if(OLDERHEADER==2) fprintf(stderr,PRINTHEADERSTDERR2,PRINTHEADERSTDERRARGS2);
  else if(OLDERHEADER==1) fprintf(stderr,PRINTHEADERSTDERR1,PRINTHEADERSTDERRARGS1);
  else if(OLDERHEADER==0) fprintf(stderr,PRINTHEADERSTDERR0,PRINTHEADERSTDERRARGS0);

  fprintf(stderr, "NEW: %d %d %d :: %22.16g %22.16g %22.16g :: %22.16g %22.16g %22.16g\n",nN1,nN2,nN3,Xmax[1],Xmax[2],Xmax[3],fakedxc,fakedyc,fakedzc);
  fprintf(stderr, "OTHER: %22.16g %22.16g %22.16g %22.16g\n",fakeRin,dxc,dyc,dzc);
   

  if(WRITEHEADER){
    if(DATATYPE>=1){
      // print out a header
      ftemp=0.0;
      if(OLDERHEADER==2) fprintf(outfile,PRINTHEADERSTDOUT2,PRINTHEADERSTDOUTARGS2);
      else if(OLDERHEADER==1) fprintf(outfile,PRINTHEADERSTDOUT1,PRINTHEADERSTDOUTARGS1);
      else if(OLDERHEADER==0) fprintf(outfile,PRINTHEADERSTDOUT0,PRINTHEADERSTDOUTARGS0);
    }
  }

}


// do things once header read-in and coordinates setup
void post_coordsetup(void)
{

  if(READHEADER){
    // if read header, then have some things that user didn't have to set on command line if using new parse mode, so set them up
    oN1=totalsize[1];
    oN2=totalsize[2];
    oN3=totalsize[3];
    // also set is R0, Rin, Rout, hslope, defcoord, gam, spin, etc. (see input_header() ).
  }

  // not doing interpolation if input and output resolutions same with no gridtype change
  // doesn't matter if refining
  doinginterpolation=!(oN0==nN0 && oN1==nN1 && oN2==nN2 && oN3==nN3 && (newgridtype==GRIDTYPENOCHANGE || oldgridtype==newgridtype));


}





// output newgrid data to file
static void output2file_postinterpolation(void)
{
  int coli,h,i,j,k;
  unsigned char uctemp;
  FTYPE ftemp;

  if(ALLOCATENEWIMAGEDATA==0){
    fprintf(stderr,"Nothing to do.  Inside output2file_postinterpolation() when ALLOCATENEWIMAGEDATA==0.  Already wrote data to file.\n");
    return;
  }


  // OUTPUT TO FILE
  fprintf(stderr,"Output to file\n"); fflush(stderr);


  OUTPUTLOOP{
    output2file_perpointcoli_postinterpolation(newimage[coli][h][i][j][k], newdata[coli][h][i][j][k]);
  }// end over OUTPUTLOOP

}



// output single point of newgrid data to file
// here, assumes input is 1-D array of quantities (i.e. coli's) as used directly by interpolation to avoid having to allocate newdata or newimage arrays
// which=0: dealing with image output
// which=1: dealing with data output
void output2file_perpoint_postinterpolation(int which, int h, int i, int j, int k, unsigned char *newimagelocal, FTYPE *newdatalocal)
{
  unsigned char uctemp;
  FTYPE ftemp;
  int coli;


  if(ALLOCATENEWIMAGEDATA==0){
    for(coli=0;coli<numoutputcols;coli++){
      output2file_perpointcoli_postinterpolation(newimagelocal[coli], newdatalocal[coli]);
    }
  }
  else{
    
    if(which==1){
      // assign (interpolated) old value to new grid position
      if(DATATYPE==0){
        for(coli=0;coli<numoutputcols;coli++) newimage[coli][h][i][j][k] = FLOAT2IMAGE(newdatalocal[coli]);
      }
      else{
        for(coli=0;coli<numoutputcols;coli++)  newdata[coli][h][i][j][k] = (FTYPE)(newdatalocal[coli]) ;
      }
    }
    else{

    }

  }
  
}


// output single point and per column of newgrid data to file
// input is actual values
void output2file_perpointcoli_postinterpolation(unsigned char newimagelocal, FTYPE newdatalocal)
{
  unsigned char uctemp;
  FTYPE ftemp;


  if(DATATYPE==0){
    fwrite(&newimagelocal, sizeof(unsigned char), 1, outfile) ;
  }
  else{
    if(imagedata==0){
      ftemp=newdatalocal;
      // if(ftemp<0.0) ftemp=0.0;
      //if(ftemp>255.0) ftemp=255.0;
      //uctemp=(unsigned char)ftemp;
      uctemp = FLOAT2IMAGE(ftemp);
      fwrite(&uctemp, sizeof(unsigned char), 1, outfile) ;
    }
    else{
      writeelement(binaryoutput,outFTYPE,outfile,newdatalocal) ;
    }
  }
}




// IMAGE WRITE FUNCTION
void writeimage(char * name, unsigned char *****image, int nt, int nx, int ny, int nz)
{
  FILE * out;
  int coli,h,i,j,k;

  if((out=fopen(name,"wb"))==NULL){
    fprintf(stderr,"Cannot open %s\n",name);
    exit(1);
  }

  coli=0;
  for(h=0;h<nt;h++){
    for(k=0;k<nz;k++){
      for(j=0;j<ny;j++){
        for(i=0;i<nx;i++){
          fwrite(&image[coli][h][i][j][k], sizeof(unsigned char), 1, out) ;
          //      fprintf(out, "%c",(unsigned char)((int)image[coli][h][i][j][k]));
        }
      }
    }
  }
  fclose(out);

}


void gcov_func(struct of_geom *ptrgeom, int getprim, int whichcoord, FTYPE *X, FTYPE *gcovinfunc, FTYPE *gcovpertinfunc)
{

  // filler function so can use metric_tools.c
}

void gcon_func(struct of_geom *ptrgeom, int getprim, int whichcoord, FTYPE *X, FTYPE *gcov, FTYPE *gcon)
{

  // filler function so can use metric_tools.c
}

void get_geometry(int ii, int jj, int kk, int pp, struct of_geom *geom)
{
  // filler function so can use metric_tools.c

  // assume time coordinate (related to oN0 and nN0) do not affect anything in metric calculations (i.e. only coordinates are affected)
  geom->i=ii;
  geom->j=jj;
  geom->k=kk;
  geom->p=pp;

}


// filler function so can use metric_tools.c
void eomfunc_func(struct of_geom *ptrgeom, int getprim, int whichcoord, FTYPE *X, FTYPE *EOMFUNCNAME)
{
  int pl,pliter;

  PLOOP(pliter,pl) EOMFUNCASSIGN(pl)=1.0;


}


void assign_eomfunc(struct of_geom *geom, FTYPE *EOMFUNCNAME)
{
  int pl,pliter;

  PLOOP(pliter,pl) geom->EOMFUNCMAC(pl)=geom->gdet;
}


// report usage of program to user and exit
void old_new(int argc, int basicargcnum)
{


}




// old report usage of program to user and exit
void old_usage(int argc, int basicargcnum)
{


  fprintf(stderr,"args (argc=%d should be %d+ (%d+ user args)): DATATYPE,INTERPTYPE, READHEADER,WRITEHEADER, oN0,oN1,oN2,oN3, refinefactor,filter,sigma, oldgridtype,newgridtype, nN0,nN1,nN2,nN3, starttc,endtc,startxc,endxc,startyc,endyc,startzc,endzc, Rin,Rout,R0,hslope,defcoord,dofull2pi, <starttdata,endtdata>,  tnrdegrees, <extrapolate,defaultvaluetype,gdumpfilepathname>\n",argc,basicargcnum,basicargcnum-1);

  fprintf(stderr,"DATATYPE:\n"
          "0=image (input&output: byte binary only, 1 column only)\n"
          "1=data (input&output: text only, 1=scalar 1 column)\n"
          "2,3,4,5=correspond to output of orthonormal vectors v^0,v^1,v^2,v^3 (inputting all 4 columns of data u^0 u^1 u^2 u^3)\n"
          "6,7,8,9=correspond to output of orthonormal vectors v^0,v^1,v^2,v^3 (inputting all 4 columns of data u_0 u_1 u_2 u_3)\n"
          "11=corresponds to output of \\detg T^x1_t[EM]/sin(\\theta) (inputting all 7 columns of data: u^t v^1 v^2 v^3 B^1 B^2 B^3)\n"
          "12=output lower component (inputting all 4 columns of data: u^i)\n"
          "13=fulldiag\n"
          "100+x=corresponds to inputting x-number of 4-vectors and outputting all 4-vectors in orthonormal basis without any interpolation\n"
          "1000+x=input fieldline file and generate certain outputs for each x=0,1,2,...\n"
          );
  fprintf(stderr,"INTERPTYPE: 0=nearest 1=bi-linear 2=planar 3=bicubic\n");
  fprintf(stderr,"READHEADER: 0=false 1=true\n");
  fprintf(stderr,"WRITEHEADER: 0=false 1=true\n");

  fprintf(stderr,"oN0: old N0 grid size\n");
  fprintf(stderr,"oN1: old N1 grid size\n");
  fprintf(stderr,"oN2: old N2 grid size\n");
  fprintf(stderr,"oN3: old N3 grid size\n");

  fprintf(stderr,"refinefactor: 1.0=no refinement, otherwise refines image before interpolation with this factor increase in size: standard is bicubic refinement\n");
  fprintf(stderr,"filter: 0=no filter #=filter image with surrounding # pixels per pixel with sigma width\n");
  fprintf(stderr,"sigma: only used if filter!=0, then sigma of gaussian filter, usually ~ filter value\n");

  fprintf(stderr,"oldgridtype (V in GRMHD code): 0=Cartesian  1=spherical polar 2=cylindrical 3=log(z) vs. log(R), 4=x'=sin\\theta log(r) z'=cos\\theta log(r) 5=Cartesian w/ light travel time accounting\n");
  fprintf(stderr,"newgridtype (output coord system): -1=no change (and rest same as above)\n");
  fprintf(stderr,"Note: Assume if oN3>1 and oldgridtype==1, then periodic in \\phi since otherwise extrapolate values and poor at low resolution.\n");
    
  fprintf(stderr,"nN0: new N0 grid size\n");
  fprintf(stderr,"nN1: new N1 grid size\n");
  fprintf(stderr,"nN2: new N2 grid size\n");
  fprintf(stderr,"nN3: new N3 grid size\n");

  fprintf(stderr,"starttc: inner interp t(t-Cart,t-Cyl t=time)\n");
  fprintf(stderr,"endtc: outer t\n");
  fprintf(stderr,"startxc: inner interp x(x-Cart,R-Cyl)\n");
  fprintf(stderr,"endxc: outer x\n");
  fprintf(stderr,"startyc: inner interp y(z-Cart,z-Cyl)\n");
  fprintf(stderr,"endyc: outer y\n");
  fprintf(stderr,"startzc: inner interp z(y-Cart,y-Cyl)\n");
  fprintf(stderr,"endzc: outer z\n");

  // some basic grid parameters, but sometimes need specific coord.c file with its parameters
  fprintf(stderr,"Rin: Inner radial edge\n");
  fprintf(stderr,"Rout: Outer radial edge\n");
  fprintf(stderr,"R0: Radial inner-grid enhancement factor\n");
  fprintf(stderr,"hslope: theta grid refinement factor\n");
  fprintf(stderr,"defcoord: which coordinate system (see coord.c)\n");
  fprintf(stderr,"dofull2pi: whether to do full 2pi or not (see coord.c)\n");

  // below are only inputted when oN0>1 || nN0>1
  fprintf(stderr,"starttdata: time 4D input dumps start (assume uniformly spaced in time, and corresponds to actual time when data exists, not FACE values, but CENT in terms of internal interpolation routines)\n");
  fprintf(stderr,"endtdata: time 4D input dumps end\n");
  fprintf(stderr,"tnrdegrees: angle [in degrees] between observer and z-axis of original grid.  0 degrees gives no transformation.  20degrees means data rotated 20degrees from z-axis towards x-axis around y-axis.\n");

  // below 1 are separately optional
  fprintf(stderr,"extrapolate: 0 = no, 1 = yes\n");
  fprintf(stderr,"defaultvaluetype: 0 = min if scalar 0 if vector, 1 = min, 2 = max, 3 = 0.0, 4 = 1E35 for v5d missingdata\n");
  // below is optional but requires above 2 to be read-in
  fprintf(stderr,"gdumpfilepathname : only if vector type (DATATYPE=(e.g.) 2,3,4,5,11,12,13,100+x,1000+x...\n");

  fprintf(stderr,"e.g.\n");
  fprintf(stderr,"~/sm/iinterp 0 0 1 1 456 456 1  1 0 0  1 0 256 512 1  1.321 40 0 40 40 0.3 0 < im0p0s0l0000.r8 > ../iimages/iim0p0s0l0000.r8\n");
  fprintf(stderr,"~/bin/iinterp.rh39 1 1 1 1  12 256 128 32  1 0 0  1 5  32 32 32 32   500 3250  -300 300 -300 300 -950 950   1.1 1000 0 0.3  9 1  500 3250 10   0 1 < dumpalltimes.1.txt > observerdumpalltimes.1.true.txt\n");

  fprintf(stderr,"\nin SM: (see blandford.m and zakamska.m)\n");
  fprintf(stderr,"$program $DATATYPE $interptype $READHEADERDATA $WRITEHEADERDATA \\ "
          "1 $nx $ny $nz $refinement 0 0  $oldgrid $igrid \\ \n"
          "1 $iinx $iiny $iinz 0 0 $iixmin $iixmax $iiymin $iiymax $iizmin $iizmax \\ \n"
          "$iRin $iRout $iR0 $ihslope $idefcoord $dofull2pi $EXTRAPOLATE $DEFAULTVALUETYPE < $1 > $2 \n");
  fprintf(stderr,"$program $1 $interptype $READHEADERDATA $WRITEHEADERDATA \\ \n"
          "1 $nx $ny $nz $refinement 0 0  $oldgrid $igrid \\ \n"
          "1 $iinx $iiny $iinz 0 0 $iixmin $iixmax $iiymin $iiymax $iizmin $iizmax \\ \n"
          "$iRin $iRout $iR0 $ihslope $idefcoord $dofull2pi $EXTRAPOLATE $DEFAULTVALUETYPE dumps/gdump < $2 > $3 \n");
  
  exit(0) ;

}



// Parse command line options as a set of switches (just template so far)
// also gives new usage
// also sets bit smarter defaults for these options so user doesn't have to give every option
void parse_commandline(int argc, char *argv[])
{
  int i;
  int ii;
  int checktdata=0;
  int usage=0;
  int goodarg=0;
  int totalgoodargs=0;
  int argcheckstart=1;
  int setbinaryinput=0,setbinaryoutput=0;
  int setbinaryinputgdump=0;
  int setinfile=0,setoutfile=0;
  int setinfilem1=0,setinfilep1=0;
  int setinFTYPE=0,setoutFTYPE=0;
  int setinFTYPEgdump=0;
  int setreadheader=0,setwriteheader=0;
  int setreadheadergdump=0,setwriteheadergdump=0;
  char **argvnew;

  if(argc>1){
    i=1;
    if (strcmp(argv[i],"-oldargs")==0) {
      fprintf(stderr,"Using old command line read method\n");
      // old type of parsing of command line

      // drop count down by 1 and shift 0-position to be argv[1] that now contains filename, so no difference noticed.
      argvnew=argv+1;

      old_parse_commandline(argc-1,argvnew); // add 1 to ignore oldargs as if doing old parsing method without any interior changes (argvnew[0] won't have filename, but that's ok -- can't just copy over since different memory space for each pointer).
      oldparse=1;
    }
  }



  // new type of parsing of command line
  if(oldparse==0){


    // check if usage should be printed, which means 
    if(argc==1){
      usage=1;
    }
    if(argc>1){
      for(i=1;i<argc;i++){
        if(strcmp(argv[i],"-usage")==0){ // usage check must come first so only 1 arg of -usage or even argc==1 will allow for usage print-out
          usage=1;
        }
      }
    }





    if(usage){
      fprintf(stderr,"Usage (argc=%d): \n\n",argc);

      fprintf(stderr,"iinterp <args> < inputfile2stdin > outputfile2stdout\n");
      fprintf(stderr,"iinterp <args> -infile inputfile -outfile outputfile\n");

      fprintf(stderr,"<args> is any of the below:\n\n");
      fprintf(stderr,"-usage (or no args): Gives Usage Information and exit (don't actually do anything with rest of args)\n");
      if(argc==1) argcheckstart=0; // forces at least one instances in loop below.  "usage ||" will check against argv[0], but doesn't matter since always triggers conditional as true
    }


    // loop over all arguments, looking for space-separated switches.  For each found switch, grab next entry as the parameter
    for(i=argcheckstart;i<argc;i++){
      // assume won't find good argument by default
      goodarg=0;

      // don't use if else if -- just use if's since want "usage" to get triggered (i.e. common triggers and not always specific unique triggers)


      // checking for -usage to trigger goodarg==1
      if(argc>1 && strcmp(argv[i],"-usage")==0){
        goodarg++;
      }

      












      //////////////////
      //
      // normal args
      //
      // could also use atoi(), atof(), and direct assignment of string pointer.
      // can also use strcmp() in a sublevel (e.g. if (strcmp(argv[i+1],"gen")==0))
      //
      /////////////////
      if(usage || strcmp(argv[i],"-version")==0 || strcmp(argv[i],"-ver")==0 || strcmp(argv[i],"--version")==0 || strcmp(argv[i],"--ver")==0 || strcmp(argv[i],"-v")==0 || strcmp(argv[i],"--v")==0 ){
        if(usage==0){
          goodarg++;
          fprintf(stderr,"iinterp %s\n\n"
                  "Jon's interpolation code for HARM post-processing.\n",
                  VERSION);
          fprintf(stderr,"         Home page: http://harm.unfuddle.com/projects/3 \n"
                  "Copyright (C) 2002-2010 Jonathan McKinney, et al.  This program is free\n"
                  "software; you can redistribute it and/or modify it under the terms of\n"
                  "the GNU General Public License, with some exceptions.\n\n"
                  "This program is distributed in the hope that it will be useful,\n"
                  "but WITHOUT ANY WARRANTY; without even the implied warranty of\n"
                  "MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\n\n"
                  "For more details, see the file license.txt in code tree.\n");
          exit(0);
        }
        else{
          fprintf(stderr,"-version -ver --version --ver -v --v : Gives Version Information\n");
        }
      }  
      if(usage || strcmp(argv[i],"-examples")==0) {
        if(usage==0){
          goodarg++;
          print_out_example_usage();
          exit(0);
        }
        else{
          fprintf(stderr,"-examples : Gives Example Usage Forms/Points\n");
        }
      }  
      if(usage || strcmp(argv[i],"-compile")==0) {
        if(usage==0){
          goodarg++;
          fprintf(stderr,"To compile as part of HARM package, do: \n\n"
                  "make superclean ; make prepiinterp ; make iinterp \n");
          exit(0);
        }
        else{
          fprintf(stderr,"-compile : Gives Compilation Information\n");
        }
      }  
      if (usage || strcmp(argv[i],"-binaryinput")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc) sscanf(argv[++i],"%d",&binaryinput) ;
          setbinaryinput=1;
          // set defaults
          if(setbinaryoutput==0){
            // default is in and out the same
            setbinaryoutput=1;
            binaryoutput=binaryinput;
          }
        }
        else{
          fprintf(stderr,"-binaryinput <binaryinput>\n");
          fprintf(stderr,"\t<binaryinput>: 0=text 1=binary (assumed little Endian or at least same Endian)\n");
        }
      }
      if (usage || strcmp(argv[i],"-binaryoutput")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc) sscanf(argv[++i],"%d",&binaryoutput) ;
          setbinaryoutput=1;
          // set defaults
          if(setbinaryinput==0){
            // default is in and out the same
            setbinaryinput=1;
            binaryinput=binaryoutput;
          }
        }
        else{
          fprintf(stderr,"-binaryoutput <binaryoutput>\n");
          fprintf(stderr,"\t<binaryoutput>: 0=text 1=binary\n");
        }
      }
      if (usage || strcmp(argv[i],"-infile")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc){
            if(binaryinput) infile=fopen(argv[++i],"rb"); // b for binary not relevant for unix
            else infile=fopen(argv[++i],"rt");
            if(infile==NULL){
              perror("fopen");
              fprintf(stderr,"Can't open infile\n");
              myexit(1);
            }
            //while(fgetc(infile)!='\n');
          }
          setinfile=1;
          // set defaults
          if(setoutfile==0){
            setoutfile=1;
            outfile=stdout;
          }
        }
        else{
          fprintf(stderr,"-infile <inputfilename>\n");
          fprintf(stderr,"\t<inputfilename>: Name of input file (used instead of stdin)\n");
        }
      }
      if (usage || strcmp(argv[i],"-infilem1")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc){
            if(binaryinput) infilem1=fopen(argv[++i],"rb"); // b for binary not relevant for unix
            else infilem1=fopen(argv[++i],"rt");
            if(infilem1==NULL){
              perror("fopen");
              fprintf(stderr,"Can't open infilem1: %s\n",argv[i]);
              myexit(1);
            }
            while(fgetc(infilem1)!='\n'); // not going to use header, so start-out at right position
          }
          setinfilem1=1;
        }
        else{
          fprintf(stderr,"-infilem1 <inputfilenamem1>\n");
          fprintf(stderr,"\t<inputfilenamem1>: Name of input file for m1 of 3-time DATATYPE==14 case\n");
        }
      }
      if (usage || strcmp(argv[i],"-infilep1")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc){
            if(binaryinput) infilep1=fopen(argv[++i],"rb"); // b for binary not relevant for unix
            else infilep1=fopen(argv[++i],"rt");
            if(infilep1==NULL){
              perror("fopen");
              fprintf(stderr,"Can't open infilep1: %s\n",argv[i]);
              myexit(1);
            }
            while(fgetc(infilep1)!='\n'); // not going to use header, so start-out at right position
          }
          setinfilep1=1;
        }
        else{
          fprintf(stderr,"-infilep1 <inputfilenamep1>\n");
          fprintf(stderr,"\t<inputfilenamep1>: Name of input file for p1 of 3-time DATATYPE==14 case\n");
        }
      }
      if (usage || strcmp(argv[i],"-outfile")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc){
            if(binaryinput) outfile=fopen(argv[++i],"wb"); // b for binary not relevant for unix
            else outfile=fopen(argv[++i],"wt");
          }
          setoutfile=1;
          // set defaults
          if(setoutfile==0){
            setinfile=1;
            infile=stdin;
          }
        }
        else{
          fprintf(stderr,"-outfile <outputfilename>\n");
          fprintf(stderr,"\t<outputfilename>: Name of output file (used instead of stdout)\n");
        }
      }
      if (usage || strcmp(argv[i],"-inFTYPE")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc){
            i++;
            if(strcmp(argv[i],"byte")==0){
              strcpy(inFTYPE,"b"); setinFTYPE=1;
            }
            else if(strcmp(argv[i],"int")==0){
              strcpy(inFTYPE,"i"); setinFTYPE=1;
            }
            else if(strcmp(argv[i],"longint")==0){
              strcpy(inFTYPE,"li"); setinFTYPE=1;
            }
            else if(strcmp(argv[i],"longlongint")==0){
              strcpy(inFTYPE,"lli"); setinFTYPE=1;
            }
            else if(strcmp(argv[i],"float")==0){
              strcpy(inFTYPE,"f"); setinFTYPE=1;
            }
            else if(strcmp(argv[i],"double")==0){
              strcpy(inFTYPE,"d"); setinFTYPE=1;
            }
            else if(strcmp(argv[i],"longdouble")==0){
              strcpy(inFTYPE,"ld"); setinFTYPE=1;
            }
            else{
              fprintf(stderr,"Unknown inFTYPE\n");
              exit(1);
            }

            // default is for in and out types to be the same
            if(setinFTYPE==1 && setoutFTYPE==0){
              setoutFTYPE=1;
              strcpy(outFTYPE,inFTYPE);
            }

          }
        }
        else{
          fprintf(stderr,"-inFTYPE <inFTYPEstring>\n");
          fprintf(stderr,"\t<inFTYPEstring>: byte, int, longint, longlongint, float, double, longdouble\n");
        }
      }
      if (usage || strcmp(argv[i],"-outFTYPE")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc){
            i++;
            if(strcmp(argv[i],"byte")==0){
              strcpy(outFTYPE,"b"); setoutFTYPE=1;
            }
            else if(strcmp(argv[i],"int")==0){
              strcpy(outFTYPE,"i"); setoutFTYPE=1;
            }
            else if(strcmp(argv[i],"longint")==0){
              strcpy(outFTYPE,"li"); setoutFTYPE=1;
            }
            else if(strcmp(argv[i],"longlongint")==0){
              strcpy(outFTYPE,"lli"); setoutFTYPE=1;
            }
            else if(strcmp(argv[i],"float")==0){
              strcpy(outFTYPE,"f"); setoutFTYPE=1;
            }
            else if(strcmp(argv[i],"double")==0){
              strcpy(outFTYPE,"d"); setoutFTYPE=1;
            }
            else if(strcmp(argv[i],"longdouble")==0){
              strcpy(outFTYPE,"ld"); setoutFTYPE=1;
            }
            else{
              fprintf(stderr,"Unknown outFTYPE\n");
              exit(1);
            }

            // default is for in and out types to be the same
            if(setoutFTYPE==1 && setinFTYPE==0){
              setinFTYPE=1;
              strcpy(inFTYPE,outFTYPE);
            }

          }
        }
        else{
          fprintf(stderr,"-outFTYPE <outFTYPEstring>\n");
          fprintf(stderr,"\t<outFTYPEstring>: byte, int, longint, longlongint, float, double, longdouble\n");
        }
      }
      if (usage || strcmp(argv[i],"-dtype")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc) sscanf(argv[++i],"%d",&DATATYPE) ; // 0,1, etc.
          // set specific defaults, but don't override user choice if already set
          if(setbinaryinput==0){
            setbinaryinput=setbinaryoutput=1;
            if(DATATYPE==0){
              binaryinput=binaryoutput=1;
              if(setreadheader==0){ setreadheader=1; READHEADER=0; }
              if(setwriteheader==0){ setwriteheader=1; WRITEHEADER=0; }
            }
            else{
              binaryinput=binaryoutput=0;
              if(setreadheader==0){ setreadheader=1; READHEADER=1; }
              if(setwriteheader==0){ setwriteheader=1; WRITEHEADER=1; }
            }
          }
        }
        else{
          fprintf(stderr,"-dtype <DATATYPE>\n");
          fprintf(stderr,"\t<DATATYPE> as one of:\n"
                  "\t0=image (input&output: byte binary default, 1 column only)\n"
                  "\t1=data (input&output: text default, 1=scalar 1 column)\n"
                  "\t2,3,4,5=correspond to output of orthonormal vectors v^0,v^1,v^2,v^3 (inputting all 4 columns of data u^0 u^1 u^2 u^3)\n"
                  "\t6,7,8,9=correspond to output of orthonormal vectors v^0,v^1,v^2,v^3 (inputting all 4 columns of data u_0 u_1 u_2 u_3)\n"
                  "\t11=corresponds to output of \\detg T^x1_t[EM]/sin(\\theta) (inputting all 7 columns of data: u^t v^1 v^2 v^3 B^1 B^2 B^3)\n"
                  "\t12=output lower component (inputting all 4 columns of data: u^i)\n"
                  "\t13=Full Diag\n"
                  "\t14=Input fieldline file and output rho, ug, vortho123, Borth123, FEMradial, Bphi all in 1 file and interpolate all at once using more memory\n"
                  "\t15=Input fieldline file and output rho, uu0, bsq all in 1 file and interpolate all at once using more memory\n"
                  "\t100+x=corresponds to inputting x-number of 4-vectors and outputting all 4-vectors in orthonormal basis without any interpolation\n"
                  "\t1000+x=Input fieldline file and output rho(x=0) ug(x=1) vortho^{0,1,2,3}(x=2,3,4,5) and Bortho^{0,1,2,3}(x=6,7,8,9) or radial energy flux(x=11) current(x=12)\n"
                  );
        }
      }
      if (usage || strcmp(argv[i],"-itype")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc) sscanf(argv[++i],"%d",&INTERPTYPE) ; // 0,1,2,3
        }
        else{
          fprintf(stderr,"-itype <INTERPTYPE>\n");
          fprintf(stderr,"\t<INTERPTYPE>: 0=nearest 1=bi-linear 2=planar 3=bicubic\n");
        }
      }
      if (usage || strcmp(argv[i],"-head")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc){ setreadheader=1; sscanf(argv[++i],"%d",&READHEADER); } // 0 or 1
          if(i+1<argc){ setwriteheader=1; sscanf(argv[++i],"%d",&WRITEHEADER); } // 0 or 1
        }
        else{
          fprintf(stderr,"-head <DOREADHEADER> <DOWRITEHEADER>\n");
          fprintf(stderr,"\t<DOREADHEADER> or <DOWRITEHEADER>: 0 or 1 for each\n");
        }
      }
      if (usage || strcmp(argv[i],"-headtype")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc){ sscanf(argv[++i],"%d",&OLDERHEADER); } // 0,1,2,...
        }
        else{
          fprintf(stderr,"-headtype <OLDERHEADER>\n");
          fprintf(stderr,"\t<OLDERHEADER>: 2=very old runlocaldipole, 1=thickdisksasha models 0=tilted models\n");
          fprintf(stderr,"\tApplies to gdump, dump, fieldline, or any input files with header.\n");
        }
      }
      if (usage || strcmp(argv[i],"-oN")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc) sscanf(argv[++i],"%d",&oN0) ;
          if(i+1<argc) sscanf(argv[++i],"%d",&oN1) ;
          if(i+1<argc) sscanf(argv[++i],"%d",&oN2) ;
          if(i+1<argc) sscanf(argv[++i],"%d",&oN3) ;
        }
        else{
          fprintf(stderr,"-oN <oN0> <oN1> <oN2> <oN3>\n");
          fprintf(stderr,"\t<oN?> : old grid sizes for (e.g.) t,r,\\theta,\\phi \n");
        }
      }
      if (usage || strcmp(argv[i],"-numcolumns")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc) sscanf(argv[++i],"%d",&numcolumns) ;
        }
        else{
          fprintf(stderr,"-numcolumns <numcolumns>\n");
          fprintf(stderr,"\t<numcolumns> : number of columns in input file.  Required if OLDERHEADER>=2\n");
        }
      }
      if (usage || strcmp(argv[i],"-refine")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc) sscanf(argv[++i],SCANARG,&refinefactor) ;// 1.0 then no refinement, just normal old image used
        }
        else{
          fprintf(stderr,"-refine <refinementfactor>\n");
          fprintf(stderr,"\t<refinementfactor>=1.0=no refinement, otherwise refines image before interpolation with this factor increase in size: standard is bicubic refinement\n");
        }
      }
      if (usage || strcmp(argv[i],"-filter")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc) sscanf(argv[++i],"%d",&filter) ;// 0=no filter #=filter given image within surrounding # pixels per pixel with sigma
          if(filter!=0 && i+1<argc) sscanf(argv[++i],SCANARG,&sigma) ;// only used if filter!=0, then sigma of gaussian filter, usually ~ filter value
        }
        else{
          fprintf(stderr,"-filter <filter> <sigma>\n");
          fprintf(stderr,"\t<filter>: 0=no filter #=filter image with surrounding # pixels per pixel with sigma width\n");
          fprintf(stderr,"\t<sigma>: only used if filter!=0, then sigma of gaussian filter, usually ~ filter value\n");
        }
      }
      if (usage || strcmp(argv[i],"-grids")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc) sscanf(argv[++i],"%d",&oldgridtype) ; // 0, 1, 2, 3, 4, and 5 currently
          if(i+1<argc) sscanf(argv[++i],"%d",&newgridtype) ; // -1, and above 0+ versions
        }
        else{
          fprintf(stderr,"-grids <oldgridtype> <newgridtype>\n");
          fprintf(stderr,"\t<oldgridtype>: (V in GRMHD code): 0=Cartesian  1=spherical polar 2=cylindrical 3=log(z) vs. log(R), 4=x'=sin\\theta log(r) z'=cos\\theta log(r) 5=Cartesian w/ light travel time accounting\n");
          fprintf(stderr,"\t<newgridtype>: (output coord system): -1=no change (and rest same as above)\n");
          fprintf(stderr,"\tNote: Assume if oN3>1 and oldgridtype==1, then periodic in \\phi since otherwise extrapolate values and poor at low resolution.\n");
        }
      }
      if (usage || strcmp(argv[i],"-nN")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc) sscanf(argv[++i],"%d",&nN0) ;
          if(i+1<argc) sscanf(argv[++i],"%d",&nN1) ;
          if(i+1<argc) sscanf(argv[++i],"%d",&nN2) ;
          if(i+1<argc) sscanf(argv[++i],"%d",&nN3) ;
        }
        else{
          fprintf(stderr,"-nN <nN0> <nN1> <nN2> <nN3>\n");
          fprintf(stderr,"\t<nN?> : new grid sizes for tc,xc,yc,zc (e.g. for Cart as for tprime,xprime,zprime,yprime as potentially rotated by tnrdegrees)  \n");
        }
      }
      if (usage || strcmp(argv[i],"-ibox")==0) {
        if(usage==0){
          goodarg++;
          //(t=time, x=R-cyl, y=Z-cyl, z=Y-cyl)
          if(i+1<argc) sscanf(argv[++i],SCANARG,&starttc) ; // arbitrary
          if(i+1<argc) sscanf(argv[++i],SCANARG,&endtc) ; // arbitrary
          if(i+1<argc) sscanf(argv[++i],SCANARG,&startxc) ; // arbitrary
          if(i+1<argc) sscanf(argv[++i],SCANARG,&endxc) ; // arbitrary
          if(i+1<argc) sscanf(argv[++i],SCANARG,&startyc) ; // arbitrary
          if(i+1<argc) sscanf(argv[++i],SCANARG,&endyc) ; // arbitrary
          if(i+1<argc) sscanf(argv[++i],SCANARG,&startzc) ; // arbitrary
          if(i+1<argc) sscanf(argv[++i],SCANARG,&endzc) ; // arbitrary
        }
        else{
          fprintf(stderr,"-ibox <starttc> <endtc> <startxc> <endxc> <startyc> <endyc> <startzc> <endzc>\n");
          fprintf(stderr,"\t<starttc>: inner interp t(t-Cart,t-Cyl t=time)\n");
          fprintf(stderr,"\t<endtc>: outer t\n");
          fprintf(stderr,"\t<startxc>: inner interp x(x-Cart,R-Cyl)\n");
          fprintf(stderr,"\t<endxc>: outer x\n");
          fprintf(stderr,"\t<startyc>: inner interp y(z-Cart,z-Cyl)\n");
          fprintf(stderr,"\t<endyc>: outer y\n");
          fprintf(stderr,"\t<startzc>: inner interp z(y-Cart,y-Cyl)\n");
          fprintf(stderr,"\t<endzc>: outer z\n");
          fprintf(stderr,"\tNote: Only need if doing interpolation\n");
        }
      }
      if (usage || strcmp(argv[i],"-coord")==0) {
        if(usage==0){
          goodarg++;
          // often other coord.c dependent stuff needed
          if(i+1<argc) sscanf(argv[++i],SCANARG,&Rin) ; // could use setRin()
          if(i+1<argc) sscanf(argv[++i],SCANARG,&Rout) ;
          if(i+1<argc) sscanf(argv[++i],SCANARG,&R0) ;
          if(i+1<argc) sscanf(argv[++i],SCANARG,&hslope) ;
        }
        else{
          fprintf(stderr,"-coord <Rin> <Rout> <R0> <hslope>\n");
          // some basic grid parameters, but sometimes need specific coord.c file with its parameters
          fprintf(stderr,"\t<Rin>: Inner radial edge\n");
          fprintf(stderr,"\t<Rout>: Outer radial edge\n");
          fprintf(stderr,"\t<R0>: Radial inner-grid enhancement factor\n");
          fprintf(stderr,"\t<hslope>: theta grid refinement factor\n");
          fprintf(stderr,"\tNote: -coord required if not reading header\n");
        }
      }
      if (usage || strcmp(argv[i],"-defcoord")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc) sscanf(argv[++i],"%d",&defcoord) ;
        }
        else{
          fprintf(stderr,"-defcoord <defcoord>\n");
          fprintf(stderr,"\t<defcoord>: which coordinate system (see coord.c)\n");
          fprintf(stderr,"\tNote: -defcoord required if not reading header\n");
        }
      }
      if (usage || strcmp(argv[i],"-dofull2pi")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc) sscanf(argv[++i],"%d",&dofull2pi) ;
        }
        else{
          fprintf(stderr,"-dofull2pi <dofull2pi>\n");
          fprintf(stderr,"\t<dofull2pi>: whether to do full 2pi or not (see coord.c)\n");
        }
      }
      if (usage || strcmp(argv[i],"-docurrent")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc) sscanf(argv[++i],"%d",&docurrent) ;
        }
        else{
          fprintf(stderr,"-docurrent <docurrent>\n");
          fprintf(stderr,"\t<docurrent>: whether to compute current (slower) if doing datatype==14\n");
        }
      }
      if (usage || strcmp(argv[i],"-tdata")==0) {
        if(usage==0){
          goodarg++;
          // below 2 for 4D data inputs, specifying start and end times for dumps used
          // also store starttdata0 and endtdata0 in case the others are modified since dual-using these variables really for DATATYPE==14
          if(i+2<argc) checktdata=1;
          if(i+1<argc){ sscanf(argv[++i],SCANARG,&starttdata); starttdata0=starttdata;}
          if(i+1<argc){ sscanf(argv[++i],SCANARG,&endtdata); endtdata0=endtdata;}
        }
        else{
          fprintf(stderr,"-tdata <starttdata> <endtdata>\n");
          // below are only inputted when oN0>1 || nN0>1
          fprintf(stderr,"\t<starttdata>: time 4D input dumps start (assume uniformly spaced in time, and corresponds to actual time when data exists, not FACE values, but CENT in terms of internal interpolation routines)\n");
          fprintf(stderr,"\t<endtdata>: time 4D input dumps end\n");
          fprintf(stderr,"\tNote: -tdata required if oN0>1 || nN1>1\n");
          fprintf(stderr,"\tAlso used to set infilem1 and infilep1 times for 3-time DATATYPE==14 procedure for getting current\n");
        }
      }
      if (usage || strcmp(argv[i],"-tnrdeg")==0) {
        if(usage==0){
          goodarg++;
          // angle for CARTLIGHT or CART grid
          if(i+1<argc) sscanf(argv[++i],SCANARG,&tnrdegrees) ;
        }
        else{
          fprintf(stderr,"-tnrdeg <tnrdegrees>\n");
          fprintf(stderr,"\t<tnrdegrees>: angle [in degrees] between observer and z-axis of original grid.  0 degrees gives no transformation.  20degrees means data rotated 20degrees from z-axis towards x-axis around y-axis.\n");
          fprintf(stderr,"\tNote: -tnrdeg recommended if want rotation or using multiple time data (i.e. -tdata with oN0>1 or nN0>1)\n");
        }
      }
      if (usage || strcmp(argv[i],"-extrap")==0) {
        if(usage==0){
          goodarg++;
          sscanf(argv[++i],"%d",&EXTRAPOLATE);
        }
        else{
          fprintf(stderr,"-extrap <extrapolate>\n");
          // below 1 are separately optional
          fprintf(stderr,"\t<extrapolate>: 0 = no, 1 = yes\n");
        }
      }
      if (usage || strcmp(argv[i],"-defaultvaluetype")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc) sscanf(argv[++i],"%d",&defaultvaluetype);
        }
        else{
          fprintf(stderr,"-defaultvaluetype <defaultvaluetype>\n");
          fprintf(stderr,"\t<defaultvaluetype>: 0 = min if scalar 0 if vector, 1 = min, 2 = max, 3 = 0.0, 4 = 1E35 for v5d missingdata\n");
        }
      }
      if (usage || strcmp(argv[i],"-smoothpole")==0) {
        if(usage==0){
          goodarg++;
          sscanf(argv[++i],"%d",&smoothpole);
        }
        else{
          fprintf(stderr,"-smoothpole <smoothpole>\n");
          fprintf(stderr,"\t<smoothpole>: 0 = no, 1 = yes\n");
        }
      }
      if (usage || strcmp(argv[i],"-gdump")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc) getgdump=1;
          if(i+1<argc) sscanf(argv[++i],"%s",&gdumpfilename[0]);
          if(setreadheadergdump==0){ setreadheadergdump=1; READHEADERGDUMP=1; }
          if(setwriteheadergdump==0){ setwriteheadergdump=1; WRITEHEADERGDUMP=1; }
        }
        else{
          fprintf(stderr,"-gdump <gdumpfilepathname>\n");
          // below is optional but requires above 2 to be read-in
          fprintf(stderr,"\t<gdumpfilepathname> : only if vector type (DATATYPE=(e.g.) 2,3,4,5,11,12,13,14,15,100+x,1000+x...\n");
        }
      }
      if (usage || strcmp(argv[i],"-gdumphead")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc){ setreadheadergdump=1; sscanf(argv[++i],"%d",&READHEADERGDUMP); } // 0 or 1
          if(i+1<argc){ setwriteheadergdump=1; sscanf(argv[++i],"%d",&WRITEHEADERGDUMP); } // 0 or 1
        }
        else{
          fprintf(stderr,"-gdumphead <DOREADHEADERGDUMP> <DOWRITEHEADERGDUMP>\n");
          fprintf(stderr,"\t<DOREADHEADERGDUMP> or <DOWRITEHEADERGDUMP>: 0 or 1 for each\n");
        }
      }
      if (usage || strcmp(argv[i],"-binaryinputgdump")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc) sscanf(argv[++i],"%d",&binaryinputgdump) ;
          setbinaryinputgdump=1;
        }
        else{
          fprintf(stderr,"-binaryinputgdump <binaryinputgdump>\n");
          fprintf(stderr,"\t<binaryinputgdump>: 0=text 1=binary (assumed little Endian or at least same Endian)\n");
        }
      }
      if (usage || strcmp(argv[i],"-inFTYPEgdump")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc){
            i++;
            if(strcmp(argv[i],"byte")==0){
              strcpy(inFTYPEgdump,"b"); setinFTYPEgdump=1;
            }
            else if(strcmp(argv[i],"int")==0){
              strcpy(inFTYPEgdump,"i"); setinFTYPEgdump=1;
            }
            else if(strcmp(argv[i],"longint")==0){
              strcpy(inFTYPEgdump,"li"); setinFTYPEgdump=1;
            }
            else if(strcmp(argv[i],"longlongint")==0){
              strcpy(inFTYPEgdump,"lli"); setinFTYPEgdump=1;
            }
            else if(strcmp(argv[i],"float")==0){
              strcpy(inFTYPEgdump,"f"); setinFTYPEgdump=1;
            }
            else if(strcmp(argv[i],"double")==0){
              strcpy(inFTYPEgdump,"d"); setinFTYPEgdump=1;
            }
            else if(strcmp(argv[i],"longdouble")==0){
              strcpy(inFTYPEgdump,"ld"); setinFTYPEgdump=1;
            }
            else{
              fprintf(stderr,"Unknown inFTYPEgdump\n");
              exit(1);
            }

          }
        }
        else{
          fprintf(stderr,"-inFTYPEgdump <inFTYPEgdumpstring>\n");
          fprintf(stderr,"\t<inFTYPEgdumpstring>: byte, int, longint, longlongint, float, double, longdouble\n");
        }
      }
      if (usage || strcmp(argv[i],"-verbose")==0) {
        if(usage==0){
          goodarg++;
          if(i+1<argc) sscanf(argv[++i],"%d",&VERBOSITY) ;
        }
        else{
          fprintf(stderr,"-verbose <VERBOSITY>\n");
          fprintf(stderr,"\t<VERBOSITY> : 0 = no extra info : 1 = some extra info : 2 = lots of extra info\n");
        }
      }
      if (usage || strcmp(argv[i],"-debug")==0){
        if(usage==0){
          goodarg++;
          if(i+1<argc) sscanf(argv[++i],"%d",&DEBUGINTERP) ;
        }
        else{
          fprintf(stderr,"-debug <DEBUGINTERP>\n");
          fprintf(stderr,"\t<DEBUGINTERP> : Level of debug for interpolation: 0 or 1 currently\n");
        }
      }
      if (usage || strcmp(argv[i],"-simpledebug")==0){
        if(usage==0){
          goodarg++;
          if(i+1<argc) sscanf(argv[++i],"%d",&SIMPLEDEBUGINTERP) ;
        }
        else{
          fprintf(stderr,"-simpledebug <SIMPLEDEBUGINTERP>\n");
          fprintf(stderr,"\t<SIMPLEDEBUGINTERP> : Level of simpledebug for interpolation: 0 or 1 currently\n");
        }
      }




      // done with good args, check how many caught this time and add to total
      totalgoodargs+=goodarg;

      // check if didn't find any good args (should always find if have consistent command line)
      if(argc>1 && goodarg==0){
        fprintf(stderr,"\ntotalgoodargs(i.e. switches)=%d\nUnknown option: %s\n\n", totalgoodargs, argv[i] );
        exit(1);
      }
 


    }// loop over command-line arguments
      



  }// end if new type of parsing of command line



  // exit if giving usage
  if(usage){
    exit(0);
  }
  else{
    if(VERBOSITY) fprintf(stderr,"totalgoodargs(i.e. switches)=%d\n",totalgoodargs);
  }


  ///////////////////////////
  //
  // If reach here, then actually got arguments instead of just showing usage
  //
  ///////////////////////////

  // some checks if actually got args
  if(nN0>1 || oN0>1 && checktdata==0){
    fprintf(stderr,"Have nN0>1 || oN0>1 but didn't set tdata, using default!\n");
  }

  // some checks if actually got sufficient args (i.e. when defaults aren't possible or don't make sense or contradict requirements)

  if(DATATYPE==14 && docurrent==1){
    if(checktdata==0){ fprintf(stderr,"DATATYPE==14 && docurrent==1 requires -tdata\n"); fflush(stderr); myexit(1); }
    if(infilem1==NULL || infilep1==NULL){ fprintf(stderr,"DATATYPE==14 && docurrent==1 requires -infilem1 and -infilep2\n"); fflush(stderr); myexit(1); }
    if(getgdump==0){ fprintf(stderr,"DATATYPE==14 && docurrent==1 requires -gdump\n"); fflush(stderr); myexit(1); }
  }


}








void print_out_example_usage(void)
{


  fprintf(stderr,"E.g. Normal Data Interpolation:\n iinterp -dtype 1 -itype 1 -head 1 1 -oN 1 128 64 128 -grids 1 0 -nN 1 128 128 1 -ibox 0 0 -40 40 -40 40 0 0 -dofull2pi 1 -defaultvaluetype 0 < infile > outfile \n\n");
  fprintf(stderr,"E.g. Full Diag:\n iinterp -binaryinput 1 -dtype 1001 -head 1 0 -dofull2pi 1 -gdump gdump < infile > outfile \n\n");
  fprintf(stderr,"E.g. Old args:\n iinterp -oldargs <alloldargs or nothing for usage information> \n\n");



  fprintf(stderr,
          "##################\n"
          "# shows how to use interpolation routine to take fieldline data and get back interpolation for each quantity desired.\n"
          "\n"
          "#\n"
          "# 1) make program\n"
          "\n"
          "cd /lustre/ki/pfs/jmckinne/harmgit_jon2interp/\n"
          "# setup for reduced code set\n"
          "rm -rf init.c init.h\n"
          "touch init.h\n"
          "\n"
          "\n"
          "# 2) ensure PRINTHEADER and SCANHEADER in global.jon_interp.h are correct for older/newer simulations (i.e. THETAROT in new only)\n"
          "# Do this by setting OLDERHEADER 1 if non-tilted runs.  Else set to 0.\n"
          "\n"
          "# 3) make program itself (need Intel MKL -- modify makefile if path needs to be changed -- currently setup for ki-rh39)\n"
          "\n"
          "make superclean ; make prepiinterp ; make iinterp &> make.log\n"
          "\n"
          "# also make bin2txt program:\n"
          "\n"
          "make superclean ; make prepbin2txt ; make bin2txt\n"
          "# check makefile and setup for ki-rh39/orange/etc.\n"
          "\n"
          "# ensure no errors during compile or link (need lapack!)\n"
          "\n"
          "##############\n"
          "4) copy programs to your path\n"
          "\n"
          "cp iinterp ~/bin/iinterp.orange.thickdisk7\n"
          "cp bin2txt ~/bin/bin2txt.orange\n"
          "\n"
          "###############\n"
          "# 5) do interpolation (directly read-in binary fieldline file and output full single file that contains interpolated data)\n"
          "\n"
          "# 0=OLDER header with 30 entries (thickdisk/sasha sims)  1=NEWER header with 32 entries (tilted sims)\n"
          "newheader=0\n"
          "\n"
          "# get 3 times so can compute temporal derivative for (e.g.) current density at same spatial/temporal location as dump\n"
          "dumpnum=5437\n"
          "dumpnumm1=$(($dumpnum-1))\n"
          "if [ -e dumps/fieldline$dumpnumm1.bin ]\n"
          "then\n"
          "    dumpnumm1=$(($dumpnum-1))\n"
          "else\n"
          "    dumpnumm1=$(($dumpnum))\n"
          "fi\n"
          "dumpnump1=$(($dumpnum+1))\n"
          "if [ -e dumps/fieldline$dumpnump1.bin ]\n"
          "then\n"
          "    dumpnump1=$(($dumpnum+1))\n"
          "else\n"
          "    dumpnump1=$(($dumpnum))\n"
          "fi \n"
          "#\n"
          "# get times of dumps\n"
          "time0=`head -1 dumps/fieldline$dumpnum.bin |awk '{print $1}'`\n"
          "timem1=`head -1 dumps/fieldline$dumpnumm1.bin |awk '{print $1}'`\n"
          "timep1=`head -1 dumps/fieldline$dumpnump1.bin |awk '{print $1}'`\n"
          "#\n"
          "# get original resolution\n"
          "nt=1\n"
          "nx=`head -1 dumps/fieldline$dumpnum.bin |awk '{print $2}'`\n"
          "ny=`head -1 dumps/fieldline$dumpnum.bin |awk '{print $3}'`\n"
          "nz=`head -1 dumps/fieldline$dumpnum.bin |awk '{print $4}'`\n"
          "if [ $newheader -eq 0 ]\n"
          "then\n"
          "    numcolumns=`head -1 dumps/fieldline$dumpnum.bin |awk '{print $30}'`\n"
          "else\n"
          "    numcolumns=`head -1 dumps/fieldline$dumpnum.bin |awk '{print $32}'`\n"
          "fi\n"
          "R0=`head -1 dumps/fieldline$dumpnum.bin |awk '{print $14}'`\n"
          "Rin=`head -1 dumps/fieldline$dumpnum.bin |awk '{print $15}'`\n"
          "Rout=`head -1 dumps/fieldline$dumpnum.bin |awk '{print $16}'`\n"
          "hslope=`head -1 dumps/fieldline$dumpnum.bin |awk '{print $17}'`\n"
          "defcoord=`head -1 dumps/fieldline$dumpnum.bin |awk '{print $19}'`\n"
          "#\n"
          "# Note that iinterp has x->xc y->zc z->yc since originally was doing 2D in x-z\n"
          "# That is:\n"
          "# So box(n)x refers to true x\n"
          "# So box(n)y refers to true z\n"
          "# So box(n)z refers to true y\n"
          "#\n"
          "# True x is V5D's x and iinterp's x\n"
          "# True z is V5D's y and iinterp's y\n"
          "# True y is V5D's z and iinterp's z\n"
          "#\n"
          "#\n"
          "# Vectors are still in order as columns as vx, vy, vz for true x,y,z, respectively\n"
          "#\n"
          "boxnt=1\n"
          "boxnx=100\n"
          "boxny=100\n"
          "boxnz=100\n"
          "boxxl=-10\n"
          "boxyl=-10\n"
          "boxzl=-10\n"
          "boxxh=10\n"
          "boxyh=10\n"
          "boxzh=10\n"
          "\n"
          "# set docurrent=0 if want quick result with no current density\n"
          "# this will change number of output columns\n"
          "docurrent=1\n"
          "\n"
          "cd /lustre/ki/pfs/jmckinne/thickdisk7/\n"
          "IDUMPDIR=/lustre/ki/pfs/jmckinne/thickdisk7/idumps/\n"
          "# ensure coordparms.dat exists here -- required to read in harm internal grid parameters\n"
          "mkdir $IDUMPDIR\n"
          "#\n"
          "#\n"
          "#\n"
          "whichoutput=14\n"
          "outfilename=$IDUMPDIR/fieldline$dumpnum.cart.bin.$boxnx.$boxny.$boxnz\n"
          "~/bin/iinterp.orange.thickdisk7 -binaryinput 1 -binaryoutput 1 -inFTYPE float -outFTYPE float -dtype $whichoutput -itype 1 -head 1 1 -oN $nt $nx $ny $nz -refine 1.0 -filter 0 -grids 1 0 -nN $boxnt $boxnx $boxny $boxnz -ibox $time0 $time0 $boxxl $boxxh $boxyl $boxyh $boxzl $boxzh -coord $Rin $Rout $R0 $hslope -defcoord $defcoord -dofull2pi 1 -docurrent $docurrent -tdata $timem1 $timep1 -extrap 1 -defaultvaluetype 0 -gdump ./dumps/gdump.bin -gdumphead 1 1 -binaryinputgdump 1 -inFTYPEgdump double -infile dumps/fieldline$dumpnum.bin -infilem1 dumps/fieldline$dumpnumm1.bin -infilep1 dumps/fieldline$dumpnump1.bin -outfile $outfilename\n"
          "\n"
          "\n"
          "# as a test, one can do just 1 variable (the density)\n"
          "if [ 1 -eq 0 ]\n"
          "then\n"
          "    outfilename=$IDUMPDIR/fieldline$dumpnum.cart.bin.densityonly.$boxnx.$boxny.$boxnz\n"
          "    ~/bin/iinterp.orange.thickdisk7 -binaryinput 1 -binaryoutput 1 -inFTYPE float -outFTYPE float -dtype 1 -itype 1 -head 1 1 -oN $nt $nx $ny $nz -refine 1.0 -filter 0 -grids 1 0 -nN $boxnt $boxnx $boxny $boxnz -ibox $time0 $time0 $boxxl $boxxh $boxyl $boxyh $boxzl $boxzh -coord $Rin $Rout $R0 $hslope -defcoord $defcoord -dofull2pi 1 -extrap 1 -defaultvaluetype 0 -infile dumps/fieldline$dumpnum.bin -outfile $outfilename\n"
          "fi\n"
          "\n"
          "\n"
          "# The whichoutput==14 case results in a file with 1 line text header, line break, then data\n"
          "# The binary data block of *floats* (4 bytes) is ordered as:\n"
          "# fastest index: column or quantity list\n"
          "# next fastest index: i (associated with true x)\n"
          "# next fastest index: j (associated with true y)\n"
          "# next fastest index: k (associated with true z)\n"
          "# slowest index: h (time, but only single time here)\n"
          "\n"
          "# Note that while array access of quantity is out of order in iinterp result, the 3D spatial grid is still written as a right-handed coordinate system.\n"
          "# So, if you face the screen showing positive z-axis pointing up (increasing j) and positive x-axis pointing to the right (increasing i), then the positive y-axis points into the screen (increasing k).\n"
          "\n"
          "# The columns or quantities in the list are ordered as:\n"
          "# rho0,ug,vx,vy,vz,Bx,By,Bz,FEMrad,Bphi,Jt,Jx,Jy,Jz  (J's only exist if -docurrent 1 was set)\n"
          "# FEMrad is the radial energy flux\n"
          "# Bphi is the poloidal enclosed current density\n"
          "# J\\mu=J^\\mu is the current density.  So the invariant current squared is J^2=J.J = -Jt*Jt + Jx*Jx + Jy*Jy + Jz*Jz (full space-time square)\n"
          "# The comoving current density is j^\\nu = J^\\mu h_\\mu^\\nu = J^\\mu (\\delta_\\mu^\\nu + u_\\mu u^\\nu) = J^\\nu + (J^\\mu u_\\mu)u^\\nu\n"
          "# So that the comoving scalar squared current is j^\\nu j_\\nu = J^2 + (J.u)^2  where u={ut,ut*vx,ut*vy,ut*vz) with ut = 1/sqrt(1-v^2) with v^2=vx^2+vy^2+vz^2 (i.e. just spatials are squared)\n"
          "# So the invariant j^2 in the comoving frame is = j^2 = J^2 + ut*(Jt + Jx*vx + Jy*vy + Jz*vz)  .  This is what would lead to dissipation in the comoving frame.\n"
          "# All vectors are orthonormal\n"
          "#\n"
          "# We can add other things, like the actual local current density, which would show where dissipation could be occuring.\n"
          "\n"
          "\n"
          "\n"
          "\n"
          "# can check how looks in text by doing:\n"
          "\n"
          "file=$outfilename\n"
          "if [ $newheader -eq 0 ]\n"
          "then\n"
          "    numoutputcols=`head -1 $file  |awk '{print $30}'`\n"
          "else\n"
          "    numoutputcols=`head -1 $fil |awk '{print $32}'`\n"
          "fi\n"
          "newnx=`head -1 $file |awk '{print $2}'`\n"
          "newny=`head -1 $file |awk '{print $3}'`\n"
          "newnz=`head -1 $file |awk '{print $4}'`\n"
          "bin2txt.orange 1 2 0 -1 3 $newnx $newny $newnz 1 $file $file.txt f $numoutputcols\n"
          "less -S $file.txt\n"
          "\n"
          "# should look reasonable.\n"

          );

  fflush(stderr);
}





// Parse command line options as a string of input variables
void old_parse_commandline(int argc, char *argv[])
{
  int i;
  int basicargcnum=32+1;



  // see if enough arguments to do anything
  if(argc < basicargcnum){
    for(i=0;i<argc;i++){
      fprintf(stderr,"argv[%d]=%s\n",i,argv[i]);
    }
    old_usage(argc,basicargcnum); // report how to use program if not enough arguments
  }
  else{
    // then just print out args
    for(i=0;i<argc;i++){
      fprintf(stderr,"argv[%d]=%s\n",i,argv[i]);
    }
  }



  // get args
  i=1;
  sscanf(argv[i++],"%d",&DATATYPE) ; // 0,1, etc.
  if(DATATYPE==0) binaryinput=1; // assume image is binary
  else binaryinput=0; // assume text

  sscanf(argv[i++],"%d",&INTERPTYPE) ; // 0,1,2,3

  sscanf(argv[i++],"%d",&READHEADER) ; // 0 or 1
  sscanf(argv[i++],"%d",&WRITEHEADER) ; // 0 or 1

  sscanf(argv[i++],"%d",&oN0) ;
  sscanf(argv[i++],"%d",&oN1) ;
  sscanf(argv[i++],"%d",&oN2) ;
  sscanf(argv[i++],"%d",&oN3) ;


  sscanf(argv[i++],SCANARG,&refinefactor) ;// 1.0 then no refinement, just normal old image used
  sscanf(argv[i++],"%d",&filter) ;// 0=no filter #=filter given image within surrounding # pixels per pixel with sigma
  sscanf(argv[i++],SCANARG,&sigma) ;// only used if filter!=0, then sigma of gaussian filter, usually ~ filter value

  sscanf(argv[i++],"%d",&oldgridtype) ; // 0, 1, 2, 3, 4, and 5 currently
  sscanf(argv[i++],"%d",&newgridtype) ; // -1, and above 0+ versions

  sscanf(argv[i++],"%d",&nN0) ; // arbitrary
  sscanf(argv[i++],"%d",&nN1) ; // arbitrary
  sscanf(argv[i++],"%d",&nN2) ; // arbitrary
  sscanf(argv[i++],"%d",&nN3) ; // arbitrary

  //(t=time, x=R-cyl, y=Z-cyl, z=Y-cyl)
  sscanf(argv[i++],SCANARG,&starttc) ; // arbitrary
  sscanf(argv[i++],SCANARG,&endtc) ; // arbitrary
  sscanf(argv[i++],SCANARG,&startxc) ; // arbitrary
  sscanf(argv[i++],SCANARG,&endxc) ; // arbitrary
  sscanf(argv[i++],SCANARG,&startyc) ; // arbitrary
  sscanf(argv[i++],SCANARG,&endyc) ; // arbitrary
  sscanf(argv[i++],SCANARG,&startzc) ; // arbitrary
  sscanf(argv[i++],SCANARG,&endzc) ; // arbitrary

  // often other coord.c dependent stuff needed
  sscanf(argv[i++],SCANARG,&Rin) ; // could use setRin()
  sscanf(argv[i++],SCANARG,&Rout) ;
  sscanf(argv[i++],SCANARG,&R0) ;
  sscanf(argv[i++],SCANARG,&hslope) ;
  sscanf(argv[i++],"%d",&defcoord) ;
  sscanf(argv[i++],"%d",&dofull2pi) ;



  if(nN0>1 || oN0>1){
    // extend basicargcnum if needed
    basicargcnum+=2;
    // below 2 for 4D data inputs, specifying start and end times for dumps used
    sscanf(argv[i++],SCANARG,&starttdata) ;
    sscanf(argv[i++],SCANARG,&endtdata) ;
  }


  // angle for CARTLIGHT or CART grid
  sscanf(argv[i++],SCANARG,&tnrdegrees) ;



  // define (at least) outputvartype
  interpret_commandlineresults_subpart1();


  // conditionally read-in things (all in or out)
  getgdump=0;
  if(argc>basicargcnum){
    
    if(argc<basicargcnum+2){
      fprintf(stderr,"argc=%d insufficient-pre\n",argc);
      exit(1);
    }
    sscanf(argv[i++],"%d",&EXTRAPOLATE);
    sscanf(argv[i++],"%d",&defaultvaluetype);

    // see if doing non-scalar output that needs metric, etc.
    if(outputvartype>0){
      if(argc!=basicargcnum+2+1){
        fprintf(stderr,"argc=%d insufficient-vector type\n",argc);
        exit(1);
      }
      sscanf(argv[i++],"%s",&gdumpfilename[0]);
      getgdump=1;
    }// end if doing non-scalar interpolation/output

  }// end if conditionally read-in things exist to be read-in
  else{
    EXTRAPOLATE=1; // default to extrapolate
    defaultvaluetype=0; // assume typical default
  }


  fprintf(stderr,"done reading %d arguments\n",i-1); fflush(stderr);

}



// Parse command line options as a string of input variables
void interpret_commandlineresults_subpart1(void)
{


  // NOTES:

  // dointerpolation:
  // Note that dointerpolation==0 or 1 is set based upon user input of grids and their sizes.  Can do interpolation under any case at the end except when doing outputvartype==1001 where do averaging or integrating (3D -> 1D or 2D) instead of interpolation
  /// 


  // immediateoutput==0 does normal interpolation if grids different or sizes different
  // immediateoutput==1 operates always per column of data (i.e. per spatial grid point) and avoids interpolation


  // outputvartype (derived from DATATYPE and other things):
  // 0 : image or data with 1 scalar input so 1 scalar output
  // 1 : convec 2 ortho (with veccomp set or set to -1 if doing all component output)
  // 2 : covvec 2 ortho (with veccomp set)
  // 11 : Compute EM Poynting term
  // 12 : Compute B_\phi (conserved current)
  // 13 : Full Diag (cleaner to process everything and then interpolate or average or integrate each item)
  //        Full means produce:
  //        dMdot dEdot dLdot T^r_tMA T^r_tEM T^r_\phiMA T^r_\phiEM
  //        d\Psi_r d\Psi_\theta
  //        T^hatr^hatphi pg pb dA' dL'
  //        d(h/r)
  //        \Omega_F
  //        (dU/d\tau) u_t dV  with some model for dU/d\tau
  //        \Delta_\thetahat \Omega vahat
  //        rho0 -u_t u^t A_\phi B^ihat v^ihat
  //        use gdump to get Connection that relates to radial gravity force that would balance magnetic force: Here need: T^x3_\nu , [ [rho0*1 + (u+p+b^2)/rho0] u^{t or phi} u_{t or phi} + ptot delta^lambda_kappa - b^lambda_kappa ] Gamma^kappa_{nu lambda} (24 things)
  // 14 : input field line and output things
  // 15 : input field line and output few things
  // 100+x : x number of 4-vectors
  // 1000+x: fieldline input file and output x-type file

  // integrationtype:
  // [for \Upsilon, get normalization when doing next step of integrating]


  // averagingtype: (for h/r or whatever)


  // differencetype: (for d_x3 or whatever)



  // defaults
  immediateoutput=0;// default is not immediate in-out
  num4vectors=1; // default
  outputvartype=0; // scalar
  vectorcomponent=0; // scalar
  numoutputcols=1; // normally old style is 1 output column since was interpolating 1 thing at a time.

  
  // set number of columns of data
  if(DATATYPE>1){


    // assume always want to transform vectors correctly
    if(DATATYPE>=2 && DATATYPE<=5){
      vectorcomponent=DATATYPE-2;
      outputvartype=1; // simple vector conversion to orthonormal basis
      fprintf(stderr,"Processing vector component %d from u^\\mu\n",vectorcomponent);
    }
    else if(DATATYPE>=6 && DATATYPE<=9){
      vectorcomponent=DATATYPE-6;
      outputvartype=2; // simple vector conversion to orthonormal basis
      fprintf(stderr,"Processing vector component %d from u_\\mu\n",vectorcomponent);
    }
    else if(DATATYPE==11){
      vectorcomponent=1;
      outputvartype=11; // Compute EM Poynting term
      fprintf(stderr,"Computing poloidal EM Polynting angular flux density\n");
    }
    else if(DATATYPE==12){
      vectorcomponent=3; // B_\\phi
      outputvartype=12; // Compute B_\\phi [conserved current]
      fprintf(stderr,"Computing B_\\phi\n");
    }
    else if(DATATYPE==13){
      fprintf(stderr,"Full Diagnostics for this data file (all except time derivative stuff)\n");
      // force input and output grid types to be the same
      outputvartype=13; // Full Diag
      immediateoutput=1; // Immediate computation of many quantities without interpolation
      vectorcomponent=-1; // indicates to output all components
      // only valid for DATATYPE=1 type of data (i.e. not images)
    }
    else if(DATATYPE==14){
      fprintf(stderr,"input field line file and output things\n");
      outputvartype=14;
      immediateoutput=0; // Immediate computation of many quantities without interpolation
      vectorcomponent=-1; // indicates to output all components
      // create, interpolate, and output all "numoutputcols" things at once
      if(docurrent)  numoutputcols=2+3*2+2+NDIM;
      else numoutputcols=2+3*2+2;
      // only valid for DATATYPE=1 type of data (i.e. not images)
    }
    else if(DATATYPE==15){
      fprintf(stderr,"input field line file and output a few things\n");
      outputvartype=15;
      immediateoutput=0; // Immediate computation of many quantities without interpolation
      vectorcomponent=-1; // indicates to output all components
      // create, interpolate, and output all "numoutputcols" things at once
      numoutputcols=4; // rho, ug, uu0, bsq
      // only valid for DATATYPE=1 type of data (i.e. not images)
    }
    else if(DATATYPE==16){
      fprintf(stderr,"input field line file and output a few things\n");
      outputvartype=16;
      immediateoutput=0;
      vectorcomponent=-1;
      numoutputcols=8;
    }
    else if(DATATYPE==17){
      fprintf(stderr,"input field line file and output a few things\n");
      outputvartype=17;
      immediateoutput=0;
      vectorcomponent=-1;
      numoutputcols=14;
    }
    else if(DATATYPE==18){
      fprintf(stderr,"input field line file and output a few things\n");
      outputvartype=18;
      immediateoutput=0;
      vectorcomponent=-1;
      numoutputcols=17+3;
    }
    else if(DATATYPE==19){
      fprintf(stderr,"input field line file with radiation and output a few things\n");
      outputvartype=19;
      immediateoutput=0;
      vectorcomponent=-1;
      numoutputcols=31;
    }
    else if(DATATYPE>=101 && DATATYPE<1000){
      num4vectors=DATATYPE-100;
      fprintf(stderr,"Transforming %d contravariant 4-vectors to orthonormal basis\n",num4vectors);
      // force input and output grid types to be the same
      outputvartype=1; // conversion to orthonormal basis
      immediateoutput=1;
      vectorcomponent=-1; // indicates to output all components
      // only valid for DATATYPE=1 type of data (i.e. not images)
    }
    else if(DATATYPE>=1000 && DATATYPE<9999){
      fprintf(stderr,"Input fieldline type file\n");
      // force input and output grid types to be the same
      int xdatatype=DATATYPE-1000;
      if(xdatatype==0) outputvartype=0; // rho
      else if(xdatatype==1) outputvartype=0; // u
      else if(xdatatype>=2 && xdatatype<=5){
        immediateoutput=0;
        vectorcomponent=xdatatype-2;// v^x0
        num4vectors=1;
        outputvartype=1; 
        fprintf(stderr,"Output v-vector=%d type file\n",vectorcomponent);
      }
      else if(xdatatype>=6 && xdatatype<=9){
        immediateoutput=0;
        vectorcomponent=xdatatype-6;// B^x0
        num4vectors=1;
        outputvartype=1; 
        fprintf(stderr,"Output B-vector=%d type file\n",vectorcomponent);
      }
      else if(xdatatype==11){
        outputvartype=11; // energy flux
        vectorcomponent=1;
        fprintf(stderr,"Output energy flux\n");
      }
      else if(xdatatype==12){
        outputvartype=12; // Current
        vectorcomponent=3;
        fprintf(stderr,"Output current\n");
      }
    }
    else{
      dualfprintf(fail_file,"No such DATATYPE=%d\n",DATATYPE);
    }

    // finally set to normal data type from now on using vectorcomponent or outputvartype
    //    DATATYPE=1; // no, leave as original DATATYPE so know file input format as well
  }
  else{
    fprintf(stderr,"Processing scalar\n");
    immediateoutput=0;// default is not immediate in-out
    outputvartype=0; // scalar
    vectorcomponent=0; // scalar
  }


  if(numoutputcols>MAXCOLS){
    fprintf(stderr,"Not enough MAXCOLS=%d for numoutputcols=%d\n",MAXCOLS,numoutputcols);
    exit(1);
  }


}




// Parse command line options as a string of input variables
void interpret_commandlineresults(void)
{

  // subpart needed for old parsing method checks of number of args
  interpret_commandlineresults_subpart1();

  ///////////////
  //
  // consistency checks
  //
  ///////////////

  // see if doing non-scalar output that needs metric, etc.
  if(outputvartype>0 && getgdump==0){
    fprintf(stderr,"Need gdump file with outputvartype>0\n");
    exit(1);
  }

  




  // set totalbc in case required
  if(INTERPTYPE==0) totalbc=0;
  else if(INTERPTYPE==1 || INTERPTYPE==2) totalbc=1;
  else if(INTERPTYPE==3) totalbc=2;
  else totalbc=MAXBC; // maximum


  // set sizes
  totalsize[0]=oN0;
  totalsize[1]=oN1;
  totalsize[2]=oN2;
  totalsize[3]=oN3;
  totalzones=totalsize[0]*totalsize[1]*totalsize[2]*totalsize[3];


  // set number of bc's per dimension
  numbc[0]=totalbc*(oN0>1);
  numbc[1]=totalbc*(oN1>1);
  numbc[2]=totalbc*(oN2>1);
  numbc[3]=totalbc*(oN3>1);






  ///////////
  //
  // set things not set by header or user that will be used (e.g. by set_points(), which sets dx[0])
  //
  ///////////


  // ensure new coordinate ignorable but no divisions by zero
  // if too narrow (or vanishing) grid width, then leave a bit resolved so no divisions by zero

  if(nN0==1){
    dtc=(endtc-starttc)/((FTYPE)nN0);
    if(fabs(dtc)<SMALL){
      dtc=NUMEPSILONPOW23;
      starttc-=dtc*0.5;
      endtc+=dtc*0.5;
    }    
  }

  if(nN1==1){
    dxc=(endxc-startxc)/((FTYPE)nN1);
    if(fabs(dxc)<SMALL){
      dxc=NUMEPSILONPOW23;
      startxc-=dxc*0.5;
      endxc+=dxc*0.5;
    }    
  }

  if(nN2==1){
    dyc=(endyc-startyc)/((FTYPE)nN2);
    if(fabs(dyc)<SMALL){
      dyc=NUMEPSILONPOW23;
      startyc-=dyc*0.5;
      endyc+=dyc*0.5;
    }    
  }

  if(nN3==1){
    dzc=(endzc-startzc)/((FTYPE)nN3);
    if(fabs(dzc)<SMALL){
      dzc=NUMEPSILONPOW23;
      startzc-=dzc*0.5;
      endzc+=dzc*0.5;
    }    
  }


  if(oN0>1){
    // dt crucial when using multiple time data.
    // Since set_points doesn't explicitly set startx[0] or dx[0] based upon any problem size information, need to set by hand.
    // set_points() will set startx[0]=0 and dx[0]=dt.
    // when oN0==1, this just keeps X[0] sane, but otherwise it's not used
    // assumes data is uniformly spaced in time (i.e. dumps were evenly spaced when merged)
    // then set_points() will set startx[0] but dx[0]=dt below, such that true lab time: tlab = starttc + dt*(hold+0.5); for hold=0..oN0-1
    // so note that if want exact correctness in time, need input starttdata and endtdata to be chosen so that data appear on CENT for given FACE versions of starttdata and endtdata
    dt=(endtdata-starttdata)/((FTYPE)oN0);
    fprintf(stderr,"Times given assumed user inputs where data sits (i.e. CENT in this code): starttdata=%21.15g endtdata=%21.15g dt=%21.15g\n",starttdata,endtdata,dt);
    // assume user inputs dump times corresopnding to location of data in time, while iinterp wants these to be FACE values where data located at CENT
    starttdata-=dt*0.5;// back up to FACE value
    endtdata+=dt*0.5;// bump up to FACE value
    dt=(endtdata-starttdata)/((FTYPE)oN0); // FACE type calculation
    fprintf(stderr,"Adjusted Times so inputted times (assumed colocated with time data) are actually FACE values that give a box with CENT values for the dump times: starttdata=%21.15g endtdata=%21.15g dt=%21.15g\n",starttdata,endtdata,dt);
    fprintf(stderr,"SUPERNOTE: User will still have to specify new-grid box size in time based upon FACE positions (i.e. not times wanted, but time box with values located at CENT)\n");
    //  dX[0]=dt; (will be set in set_points()
    // So X[0] = starttdata + (hold + startpos[0] + 0.5) dx[0]; and dx[0]=dX[0]=dt = (endtdata-starttdata)/oN0;
  }
  else{
    // need to make time coordinate ignorable in case user set the start and end times to be the same
    // avoids divisions by zero
    dt=1.0;
    starttdata=starttc;
    endtdata=endtc;
  }





  if(filter && (oN3!=1 || oN0!=1)){
    filter=0;
    fprintf(stderr,"Turned off filter since oN3=%d or  oN0=%d\n",oN3,oN0); fflush(stderr);
  }


  if(fabs(refinefactor-1.0)>0.1 && (oN3!=1 || oN0!=1) ){
    refinefactor=1.0;
    fprintf(stderr,"Turned off refinement since oN3=%d or oN0=%d\n",oN3,oN0); fflush(stderr);
  }

  if( (oN3>1 || oN0>1) && (INTERPTYPE==3 || INTERPTYPE==2) ){
    fprintf(stderr,"PLANAR and BICUBIC interpolation not setup for oN3=%d>1 or oN0=%d>1 -- uses nearest for k,h",oN3,oN0);
  }


  if(READHEADER)  jonheader=1;
  else jonheader=0;



  // setup case where not interpolating such that grid and grid sizes don't change (i.e. no interpolation)
  if(immediateoutput!=0){
    // force this even if user messed up
    newgridtype=GRIDTYPENOCHANGE;
    // force output grid size to be same as input
    nN0=oN0;
    nN1=oN1;
    nN2=oN2;
    nN3=oN3;
  }




}




// set default options
void defaultoptions(void)
{

  // These are dumb defaults.  Bit smarter defaults set when doing new parsing, so user doesn't have to give all options always.

  infile=stdin;
  outfile=stdout;

  infilem1=NULL;
  infilep1=NULL;

  DATATYPE=1; binaryinput=0; strcpy(inFTYPE,"d");

  INTERPTYPE=1;
  READHEADER=1;
  WRITEHEADER=1;
  OLDERHEADER=0;

  binaryoutput=0; strcpy(outFTYPE,"d");


  oN0=1;
  oN1=62;
  oN2=62;
  oN3=62;

  refinefactor=1.0;
  filter=0;
  sigma=1.0;

  oldgridtype=1;
  newgridtype=0;
  
  nN0=1;
  nN1=64;
  nN2=64;
  nN3=64;
  
  starttc=0;
  endtc=2000;
  startxc=-40;
  endxc=40;
  startyc=-40;
  endyc=40;
  startzc=-40;
  endzc=40;

  Rin=1.1;
  Rout=40;
  R0=0;
  hslope=0.3;

  defcoord=0;

  dofull2pi=1;

  docurrent=0;

  starttdata=0;
  endtdata=2000;

  tnrdegrees=0;

  getgdump=0;
  strcpy(&gdumpfilename[0],"NOFILESET");

  EXTRAPOLATE=1; // default to extrapolate
  defaultvaluetype=0; // assume typical default
  smoothpole=0;

  immediateoutput=0;// default is not immediate in-out
  outputvartype=0; // scalar
  vectorcomponent=0; // scalar

  READHEADERGDUMP=1;
  WRITEHEADERGDUMP=1;
  binaryinputgdump=1;
  strcpy(inFTYPEgdump,"d");

  DEBUGINTERP=0;
  SIMPLEDEBUGINTERP=0;
  VERBOSITY=1; // default to moderate verbosity
  



}

// should contain whatever user version of coordinates exist in the relevant init.c file.
#include "jon_interp_coorduser.c"


